---
id: practical-guide-ai-spec-driven-development
title: 実践ガイド - AI Spec Driven Development
version: 1.0.0
status: active
created: 2025-11-07
updated: 2025-11-07
owner: feel-flow
phase: mvp
tags: [ai, documentation, development, practical-guide]
references:
   - docs/AI_SPEC_DRIVEN_DEVELOPMENT.md
   - docs/DEEP_DIVE.md
   - docs/AI_CONFIG_BEST_PRACTICES.md
changeImpact: medium
---

# 実践ガイド：AI Spec Driven Development

> **関連文書**:
>
> - [概念と実践](AI_SPEC_DRIVEN_DEVELOPMENT.md) - AI Spec Driven Developmentのコアコンセプト
> - [深掘り](DEEP_DIVE.md) - 理論的背景と詳細な分析
> - [AIツール設定ファイルのベストプラクティス](AI_CONFIG_BEST_PRACTICES.md) - CLAUDE.md / AGENTS.md / copilot-instructions.md / .cursorrules 横断ガイド

## 目次

- [実践ガイド：AI Spec Driven Development](#実践ガイドai-spec-driven-development)
  - [目次](#目次)
  - [1. 実践編：各文書の詳細解説](#1-実践編各文書の詳細解説)
    - [1.1 MASTER.md - すべての中心](#11-mastermd---すべての中心)
      - [1.1.1 ドキュメントの必要性](#111-ドキュメントの必要性)
      - [1.1.2 記載事項](#112-記載事項)
      - [1.1.3 活用事例](#113-活用事例)
    - [1.2 PROJECT.md - ビジョンと要件の統合](#12-projectmd---ビジョンと要件の統合)
      - [1.2.1 ドキュメントの必要性](#121-ドキュメントの必要性)
      - [1.2.2 記載事項](#122-記載事項)
      - [1.2.3 活用事例](#123-活用事例)
    - [1.3 ARCHITECTURE.md - システム設計の中核](#13-architecturemd---システム設計の中核)
      - [1.3.1 ドキュメントの必要性](#131-ドキュメントの必要性)
      - [1.3.2 記載事項](#132-記載事項)
      - [1.3.3 活用事例](#133-活用事例)
    - [1.4 DOMAIN.md - ビジネスロジックの集約](#14-domainmd---ビジネスロジックの集約)
      - [1.4.1 ドキュメントの必要性](#141-ドキュメントの必要性)
      - [1.4.2 記載事項](#142-記載事項)
      - [1.4.3 活用事例](#143-活用事例)
    - [1.5 PATTERNS.md - 実装パターンガイド](#15-patternsmd---実装パターンガイド)
      - [1.5.1 ドキュメントの必要性](#151-ドキュメントの必要性)
      - [1.5.2 記載事項](#152-記載事項)
      - [1.5.3 活用事例](#153-活用事例)
    - [1.6 TESTING.md - AI駆動テスト戦略](#16-testingmd---ai駆動テスト戦略)
      - [1.6.1 ドキュメントの必要性](#161-ドキュメントの必要性)
      - [1.6.2 記載事項](#162-記載事項)
      - [1.6.3 活用事例](#163-活用事例)
    - [1.7 DEPLOYMENT.md - 配布とリリース戦略](#17-deploymentmd---配布とリリース戦略)
      - [1.7.1 ドキュメントの必要性](#171-ドキュメントの必要性)
      - [1.7.2 記載事項](#172-記載事項)
      - [1.7.3 活用事例](#173-活用事例)
    - [1.8 08-knowledge/ - ナレッジ蓄積・学習](#18-08-knowledge---ナレッジ蓄積学習)
    - [1.9 07-project-management/ - プロジェクト管理](#19-07-project-management---プロジェクト管理)
  - [2. 移行戦略：既存プロジェクトからの転換](#2-移行戦略既存プロジェクトからの転換)
    - [2.1 段階的移行アプローチ](#21-段階的移行アプローチ)
    - [2.2 チーム教育](#22-チーム教育)
      - [2.2.1 チーム向けガイドライン](#221-チーム向けガイドライン)
        - [やるべきこと ✅](#やるべきこと-)
        - [やってはいけないこと ❌](#やってはいけないこと-)
  - [3. 実践事例：Before/After](#3-実践事例beforeafter)
    - [3.1 従来の人間中心アプローチ](#31-従来の人間中心アプローチ)
    - [3.2 AI最適化アプローチ](#32-ai最適化アプローチ)
    - [3.3 生成されたコードの比較](#33-生成されたコードの比較)
  - [4. 実装ロードマップ](#4-実装ロードマップ)
    - [4.1 小規模プロジェクト（1-3人）](#41-小規模プロジェクト1-3人)
    - [4.2 中規模プロジェクト（4-10人）](#42-中規模プロジェクト4-10人)
    - [4.3 大規模プロジェクト（10人以上）](#43-大規模プロジェクト10人以上)
  - [5. Claude Skillsによる実践的活用](#5-claude-skillsによる実践的活用)
    - [5.1 Claude Skillsとは](#51-claude-skillsとは)
    - [5.2 AI仕様駆動開発スキルの導入](#52-ai仕様駆動開発スキルの導入)
    - [5.3 スキルによる自動化機能](#53-スキルによる自動化機能)
    - [5.4 実践例：プロジェクトライフサイクル全体での活用](#54-実践例プロジェクトライフサイクル全体での活用)
    - [5.5 チーム導入のベストプラクティス](#55-チーム導入のベストプラクティス)
  - [6. GitHub Copilot Review Routerによるコードレビュー自動化](#6-github-copilot-review-routerによるコードレビュー自動化)
    - [6.1 背景と課題](#61-背景と課題)
    - [6.2 Review Routerパターン](#62-review-routerパターン)
      - [ディレクトリ構造](#ディレクトリ構造)
      - [アーキテクチャ](#アーキテクチャ)
      - [設計の要点](#設計の要点)
      - [VS Code Extension API との違い](#vs-code-extension-api-との違い)
    - [6.3 スキル選択の自動化](#63-スキル選択の自動化)
      - [必須スキル（常に実行）](#必須スキル常に実行)
      - [条件付きスキル（変更内容に応じて実行）](#条件付きスキル変更内容に応じて実行)
      - [統合レポートの判定基準](#統合レポートの判定基準)
    - [6.4 使用方法](#64-使用方法)
      - [基本的な使い方](#基本的な使い方)
      - [特定スキルのみ実行](#特定スキルのみ実行)
      - [Git Workflowへの統合](#git-workflowへの統合)
      - [セットアップ](#セットアップ)
    - [6.5 Claude Code pr-review-toolkit との比較](#65-claude-code-pr-review-toolkit-との比較)
  - [7. AIツール設定ファイルのベストプラクティス](#7-aiツール設定ファイルのベストプラクティス)

## 1. 実践編：各文書の詳細解説

### 1.1 MASTER.md - すべての中心

#### 1.1.1 ドキュメントの必要性

MASTER.mdは、AI駆動開発の心臓部となる文書です。人間がプロジェクトに参加する際、最初に「このプロジェクトは何？」と質問するように、AIも同様にプロジェクトの全体像を把握する必要があります。しかし、AIには人間のような文脈推測能力がないため、明確で構造化された情報が必要です。

この文書は、AIが最初に読み込む「エグゼクティブサマリー」として機能し、プロジェクトの80%の情報を瞬時に理解できるよう設計されています。

#### 1.1.2 記載事項

1. **プロジェクト識別情報**
   - プロジェクト名、バージョン、使用するAIツール
   - 最終更新日（AIが情報の鮮度を判断するため）

2. **30秒で理解できるプロジェクト概要**
   - 何を作るのか（What）
   - なぜ作るのか（Why）
   - 誰のためか（Who）

3. **技術的な基本方針**
   - 採用する技術スタック
   - アーキテクチャパターン
   - 主要な設計原則

4. **AIへの明確な指示**
   - 必ず守るべきルール
   - 推奨される実装パターン
   - 絶対に避けるべきアンチパターン

5. **実装の優先順位**
   - 機能の重要度順リスト
   - MVPの範囲

6. **各詳細文書への道標**
   - どの情報がどの文書にあるかの索引

#### 1.1.3 活用事例

AIは新しいタスクを開始する際、必ずMASTER.mdを参照します。例えば「ユーザー認証機能を実装して」という指示を受けた場合、AIは以下のプロセスで活用します：

1. 技術スタックを確認（JWT認証なのか、セッション認証なのか）
2. コーディングルールを確認（TypeScriptの使用、エラーハンドリング方式）
3. 実装パターンを確認（Resultパターンの使用）
4. 詳細情報が必要な場合は、参照先の文書を確認

人間の開発者にとっても、新規参加時の最初の1文書として機能し、プロジェクトの全体像を素早く把握できます。

### 1.2 PROJECT.md - ビジョンと要件の統合

#### 1.2.1 ドキュメントの必要性

PROJECT.mdは、プロジェクトの「なぜ」と「何を」を定義する文書です。従来の開発では、ビジネス要件、機能要件、非機能要件、ユーザーストーリーなどが別々の文書に分散していました。しかし、AIにとってこの分散は、関連情報を結びつける際の障害となります。

この文書は、プロジェクトの本質的な価値と実現すべき機能を1箇所に集約し、AIが要件を正確に理解して適切なコードを生成できるようにします。

#### 1.2.2 記載事項

1. **ビジョンとミッション**
   - プロジェクトが実現したい未来像
   - 解決したい課題の本質
   - 提供する価値提案

2. **成功の定義**
   - 定量的な成功指標（KPI）
   - 定性的な成功基準
   - 測定方法とタイミング

3. **機能要件**
   - ユーザーストーリー形式での要件定義
   - 具体的なシナリオとユースケース
   - ビジネスルールとドメインロジック
   - 受入基準

4. **非機能要件**
   - パフォーマンス要件（応答速度、同時接続数）
   - セキュリティ要件（認証方式、データ保護）
   - 可用性・信頼性要件（稼働率、障害復旧）
   - アクセシビリティ要件

5. **フェーズ計画**
   - MVP（最小実行可能製品）の範囲
   - 段階的なリリース計画
   - 各フェーズの目標と成果物

#### 1.2.3 活用事例

AIは機能を実装する際、PROJECT.mdを参照して以下を確認します。

- 実装する機能がビジョンに沿っているか
- ビジネスルールを正しく理解しているか
- 非機能要件を満たす実装になっているか
- 現在のフェーズで実装すべき機能か

また、プロダクトオーナーや開発者間の認識を統一する「契約書」としても機能し、スコープクリープを防ぐ役割も果たします。

### 1.3 ARCHITECTURE.md - システム設計の中核

#### 1.3.1 ドキュメントの必要性

ARCHITECTURE.mdは、システムの技術的な構造と設計思想を定義する文書です。建築における設計図のように、AIがコードを生成する際の「青写真」として機能します。

AIは優れたパターン認識能力を持っていますが、プロジェクト固有のアーキテクチャ決定を推測することはできません。この文書により、AIは適切なレイヤー分離、依存関係の方向、データフローを理解し、アーキテクチャに準拠したコードを生成できます。

#### 1.3.2 記載事項

1. **システム全体図**
   - コンポーネントの配置と関係
   - データの流れ
   - 外部システムとの連携
   - インフラストラクチャ構成

2. **レイヤーアーキテクチャ**
   - 各レイヤーの責務と境界
   - レイヤー間の依存関係ルール
   - 具体的なディレクトリ構造
   - 各レイヤーで使用可能な技術

3. **主要な設計パターン**
   - 採用する設計パターンとその理由
   - パターンの適用場所と方法
   - プロジェクト固有のカスタマイズ
   - 避けるべきアンチパターン

4. **データフロー設計**
   - リクエスト/レスポンスの流れ
   - 状態管理の方針
   - キャッシュ戦略
   - イベント駆動の部分

5. **エラーハンドリング設計**
   - エラーの分類と処理方針
   - エラーの伝播ルール
   - リトライ戦略
   - ログ出力方針

6. **スケーラビリティ設計**
   - 垂直・水平スケーリングの方針
   - パフォーマンス最適化の指針
   - ボトルネックの想定と対策
   - 将来の拡張性考慮

#### 1.3.3 活用事例

AIは新しいコンポーネントやサービスを実装する際、ARCHITECTURE.mdを参照して以下を確認します。

- どのレイヤーに配置すべきか判断
- 他のコンポーネントとの連携方法を決定
- 適切な設計パターンを選択
- エラーハンドリングの実装方法を統一

また、アーキテクチャレビューの基準書として、チーム全体でアーキテクチャの一貫性を保つためにも活用されます。

### 1.4 DOMAIN.md - ビジネスロジックの集約

#### 1.4.1 ドキュメントの必要性

DOMAIN.mdは、ビジネスの本質的なルールとロジックを技術的に表現する文書です。ドメイン駆動設計（DDD）の考え方に基づき、ビジネスの複雑さを管理可能な形でモデル化します。

AIは汎用的な実装パターンは理解できますが、特定のビジネスドメインの知識は持っていません。この文書により、AIはビジネスルールを正確に理解し、ドメインの整合性を保った実装を生成できます。

#### 1.4.2 記載事項

1. **ドメインの概要**
   - ビジネスドメインの説明
   - コアドメインとサブドメインの識別
   - ドメイン間の関係性
   - ユビキタス言語の定義

2. **エンティティ定義**
   - ビジネス上の主要な概念
   - 各エンティティの責務と属性
   - ライフサイクルと状態遷移
   - ビジネス識別子

3. **値オブジェクト**
   - ビジネス上の値を表現する不変オブジェクト
   - バリデーションルール
   - ビジネスロジックのカプセル化
   - 等価性の定義

4. **集約とトランザクション境界**
   - データ整合性の単位
   - 集約ルートの定義
   - トランザクション境界の明確化
   - 並行性の制御

5. **ドメインサービス**
   - 複数のエンティティにまたがるビジネスロジック
   - 外部サービスとの連携ロジック
   - 複雑な計算ロジック

6. **ドメインイベント**
   - ビジネス上の重要な出来事
   - イベントの発生条件と影響範囲
   - イベント駆動の処理フロー

7. **ビジネスルール集**
   - 計算式と係数
   - 制約条件と検証ルール
   - 業務フローと状態遷移
   - 例外的なケースの扱い

#### 1.4.3 活用事例

AIはビジネスロジックを実装する際、DOMAIN.mdを参照して以下を実施します。

- 正しいビジネスルールを適用
- ドメインオブジェクトの整合性を保証
- 適切なバリデーションを実装
- ビジネスイベントを正しく発火

また、ドメインエキスパートと開発者の共通言語として機能し、ビジネス要求と技術実装のギャップを埋める役割も果たします。

### 1.5 PATTERNS.md - 実装パターンガイド

#### 1.5.1 ドキュメントの必要性

PATTERNS.mdは、プロジェクトで採用する実装パターンと、避けるべきアンチパターンを明確に定義する文書です。AIがコードを生成する際の「スタイルガイド」として機能します。

AIは様々な実装方法を知っていますが、プロジェクトごとに最適なパターンは異なります。この文書により、AIは一貫性のある、プロジェクトの方針に沿ったコードを生成できます。

#### 1.5.2 記載事項

1. **エラーハンドリングパターン**
2. **非同期処理パターン**
3. **データアクセスパターン**
4. **バリデーションパターン**
5. **テストパターン**
6. **セキュリティパターン**
7. **パフォーマンスパターン**

#### 1.5.3 活用事例

AIは具体的な機能を実装する際、PATTERNS.mdを参照して以下を適用します。

- プロジェクトで推奨されるパターンを選択
- アンチパターンを回避
- 一貫性のあるコードスタイルを維持
- ベストプラクティスに従った実装

また、コードレビューの基準として活用され、新規参加メンバーの学習教材としても機能します。

### 1.6 TESTING.md - AI駆動テスト戦略

#### 1.6.1 ドキュメントの必要性

TESTING.mdは、プロジェクトのテスト戦略と具体的なテスト実装方法を定義する文書です。AI駆動開発では、コードと同時にテストコードも生成することが重要であり、この文書がAIにテストの書き方を指示します。

#### 1.6.2 記載事項

1. **テスト戦略の全体像**
2. **テストコード生成ルール**
3. **ユニットテストの方針**
4. **統合テストの方針**
5. **E2Eテストの方針**
6. **テストデータ管理**
7. **パフォーマンステスト**
8. **CI/CDとの統合**

#### 1.6.3 活用事例

AIは新しい機能を実装する際、TESTING.mdを参照して以下を決定します。

- 適切なテストレベルとカバレッジを決定
- プロジェクトのテストパターンに従ったテストコードを生成
- エッジケースや異常系のテストを網羅
- CI/CDパイプラインで実行可能なテストを作成

### 1.7 DEPLOYMENT.md - 配布とリリース戦略

#### 1.7.1 ドキュメントの必要性

DEPLOYMENT.mdは、プロジェクトの配布プロセスとリリース戦略を定義する文書です。AI駆動開発では、迅速な開発サイクルに対応した効率的なデプロイメント戦略が必要であり、この文書がAIにリリースプロセスを指示します。

#### 1.7.2 記載事項

1. **CI/CDパイプライン設定**
2. **環境別設定**
3. **リリース戦略**

#### 1.7.3 活用事例

AIはリリース準備を行う際、DEPLOYMENT.mdを参照して以下を実行します。

- 適切なデプロイメント手順を実行
- 環境固有の設定を適用
- 品質ゲートの通過を確認
- リリース後の監視項目を把握

### 1.8 08-knowledge/ - ナレッジ蓄積・学習

このフォルダは、プロジェクトの成長とともに価値が高まる重要な構成要素です。開発過程で発生する問題と解決策、ベストプラクティス、よくある質問を蓄積することで、チーム全体の学習効率を大幅に向上させます。

- **LESSONS_LEARNED.md**: 開発過程で得た知見・解決策
- **TROUBLESHOOTING.md**: トラブルシューティング集
- **BEST_PRACTICES.md**: ベストプラクティス集
- **FAQ.md**: よくある質問と回答

### 1.9 07-project-management/ - プロジェクト管理

このフォルダは、プロジェクト管理関連文書を集約します。チーム規模が拡大したり、開発期間が長期にわたる場合に特に重要になります。

- **ROADMAP.md**: ロードマップと計画
- **TASKS.md**: タスク管理と進捗
- **RISKS.md**: リスク管理と対策

## 2. 移行戦略：既存プロジェクトからの転換

### 2.1 段階的移行アプローチ

既存の大規模ドキュメントから移行する際の実践的なステップを以下に示します。

**Phase 1: 現状分析（1週間）**
- ドキュメント使用頻度の分析 (Gitログ活用)
- 最も参照される上位10文書を特定

**Phase 2: 統合と簡素化（2週間）**
- 重複情報の特定と削除
- 関連文書の統合
- 7カテゴリへの再編成

**Phase 3: AIテストと調整（1週間）**
- AIツールでの動作確認
- フィードバックに基づく改善
- チームレビューの実施

### 2.2 チーム教育

#### 2.2.1 チーム向けガイドライン

##### やるべきこと ✅
- MASTER.mdを常に最新に保つ
- 具体的な実装例を文書に含める
- AIへの明確な指示を記載

##### やってはいけないこと ❌
- 同じ情報を複数箇所に記載
- 抽象的な説明に留める
- 人間向けのプロセス文書を増やす

## 3. 実践事例：Before/After

### 3.1 従来の人間中心アプローチ

```
開発者: 「ユーザー認証機能を実装してください」
AI: 「どの文書を参照すべきですか？」
開発者: 「AUTHENTICATION_SETUP.mdとSECURITY_IMPLEMENTATION.mdと...」
AI: *4つの文書を読み込み... 12,000トークン消費*
AI: 「認証方式についてJWTとセッションの記述が異なりますが...」

結果: 30分経過、まだコードは1行も生成されていない
```

### 3.2 AI最適化アプローチ

```
開発者: 「ユーザー認証機能を実装してください」
AI: *MASTER.mdを読み込み... 2,000トークン*
AI: 「了解しました。以下の仕様で実装します...」

// 5分後: 完全な認証システムが生成される
```

### 3.3 生成されたコードの比較

AI最適化ドキュメントにより、一貫性のある実装が生成されます。適切な依存性注入、包括的なエラーハンドリング、セキュリティベストプラクティスの実装、レートリミッティング機能が含まれ、型安全性も確保されています。

## 4. 実装ロードマップ

### 4.1 小規模プロジェクト（1-3人）
- **期間**: 1-3ヶ月
- **ドキュメント**: 最小限の7文書で十分
- **重点**: MASTER.md, PROJECT.md, ARCHITECTURE.md の整備

### 4.2 中規模プロジェクト（4-10人）
- **期間**: 3-12ヶ月
- **ドキュメント**: 階層化を開始。`08-knowledge/` を拡充。
- **重点**: DOMAIN.md, PATTERNS.md の詳細化。`07-project-management/` の導入。

### 4.3 大規模プロジェクト（10人以上）
- **期間**: 1年以上
- **ドキュメント**: 全てのカテゴリを詳細化。
- **重点**: `06-reference/` (ADR, 用語集) の整備。チーム間の連携を強化。

## 5. Claude Skillsによる実践的活用

### 5.1 Claude Skillsとは

Claude Skillsは、特定のタスクやワークフローを自動化するためのカスタムツールセットです。AI仕様駆動開発の原則をスキルとして定義することで、開発プロセス全体を効率化できます。

> **Commands vs Skills の使い分け**: コマンドとスキルはコンテキスト管理戦略が異なる。コードレビューのような重い処理はスキル（サブエージェント）で隔離実行し、メインセッションのコンテキストを節約すべきである。詳細は [Commands vs Skills ガイド](CLAUDE_CODE_COMMANDS_SKILLS.md) を参照。

### 5.2 AI仕様駆動開発スキルの導入
`MASTER.md` や `PATTERNS.md` の内容を基に、以下のようなスキルを定義します。
- `create_component`: ARCHITECTURE.mdのレイヤー構造に従ってコンポーネントを生成
- `generate_test`: TESTING.mdのルールに基づきテストコードを生成
- `refactor_code`: PATTERNS.mdのベストプラクティスを適用

### 5.3 スキルによる自動化機能
- **仕様書からのコード生成**: `PROJECT.md` のユーザーストーリーから直接コードとテストを生成
- **一貫性チェック**: プロジェクト全体のコードベースが `PATTERNS.md` に準拠しているか自動検証
- **ドキュメント更新**: コード変更時に影響を受けるドキュメントを自動で更新提案

### 5.4 実践例：プロジェクトライフサイクル全体での活用
1. **計画**: `PROJECT.md` からタスクを自動生成
2. **実装**: `create_component` スキルで雛形を作成し、AIがロジックを実装
3. **テスト**: `generate_test` スキルでテストを自動生成
4. **レビュー**: `refactor_code` スキルでコードを自動整形・改善
5. **デプロイ**: `DEPLOYMENT.md` に基づき、デプロイスクリプトを自動生成

### 5.5 チーム導入のベストプラクティス

- **共有スキルセットの構築**: チームで共通のスキルセットを開発・共有
- **段階的導入**: まずは単純なタスクから自動化し、徐々に範囲を拡大
- **継続的改善**: スキルの利用状況を分析し、定期的に改善

## 6. GitHub Copilot Review Routerによるコードレビュー自動化

### 6.1 背景と課題

GitHub Copilot の `.agent.md` 宣言的モデルには、設計上の重要な制約があります。

**制約**: Skill（tool）から他のSkillを呼び出すことができない

Claude Code の `pr-review-toolkit` では、複数のスキル（code-reviewer、silent-failure-hunter、pr-test-analyzer等）を独立して定義し、それぞれを個別に呼び出す設計が採用されています。しかし、GitHub Copilot のエージェントモデルでは、あるスキルが別のスキルを自動的に呼び出す「スキル間連携」ができません。

これにより、PRレビュー時に以下の課題が生じます：

1. **手動呼び出しの負担**: 6つのレビューエージェントを個別に呼び出す必要がある
2. **判断の属人化**: どのレビューが必要かの判断が開発者に依存する
3. **網羅性の欠如**: 必要なレビューの実行漏れが発生しやすい

### 6.2 Review Router アーキテクチャ

この制約を克服するため、**Copilot CLI によるセッション分離パターン**を採用しました。

#### アーキテクチャの進化

| 世代 | パターン | セッション分離 | コンテキスト効率 |
| ------ | ---------- | -------------- | ---------------- |
| v1 | 全スキル埋め込み | 不可 | 低（常に全スキルがコンテキストに載る） |
| v2 | 動的 `read_file` 読み込み | 不可 | 中（条件付きスキルを省略可能） |
| **v3** | **Copilot CLI セッション分離** | **実現** | **高（各スキルが独立プロセス）** |

#### ディレクトリ構造

```text
.github/
├── agents/
│   ├── review-router.agent.md      ← ルーター（実行制御）
│   └── skills/                      ← VS Code Chat 用（従来互換）
│       ├── code-review.md
│       ├── error-handler-hunt.md
│       ├── test-analysis.md
│       ├── type-design-analysis.md
│       ├── comment-analysis.md
│       └── code-simplification.md
├── skills/                          ← 公式 Agent Skills 形式（Copilot CLI 用）
│   ├── code-review/SKILL.md
│   ├── error-handler-hunt/SKILL.md
│   ├── test-analysis/SKILL.md
│   ├── type-design-analysis/SKILL.md
│   ├── comment-analysis/SKILL.md
│   └── code-simplification/SKILL.md
scripts/
├── review.sh                        ← Copilot CLI 実行スクリプト（macOS/Linux）
└── review.ps1                       ← Copilot CLI 実行スクリプト（Windows）
```

#### セッション分離アーキテクチャ（推奨）

```
ユーザー → @review-router (VS Code Chat)
  │
  ├─ run_in_terminal: bash scripts/review.sh --all --parallel
  │   │
  │   ├─ copilot -p "Code Review..."        [独立セッション1] → .review-results/code-review.md
  │   ├─ copilot -p "Error Handler Hunt..." [独立セッション2] → .review-results/error-handler-hunt.md
  │   ├─ copilot -p "Test Analysis..."      [独立セッション3] → .review-results/test-analysis.md
  │   └─ ... (並列実行可能)
  │   │
  │   └─ → .review-results/review-report.md (統合レポート)
  │
  └─ read_file: .review-results/review-report.md
     → 統合レポートをユーザーに表示
```

**ポイント**: 各 `copilot -p` 呼び出しは独立したLLMセッション。Router のコンテキストにはスキル定義が一切載らず、結果ファイルのみを読み込みます。

#### 設計の要点

1. **真のセッション分離**: 各スキルが独立した `copilot -p` プロセスで実行。コンテキスト汚染ゼロ
2. **並列実行**: `--parallel` オプションで全スキルを同時実行可能
3. **自動スキル判定**: `scripts/review.sh` が変更ファイルのパターンから条件付きスキルの要否を自動判定
4. **公式 Agent Skills 形式**: `.github/skills/*/SKILL.md` は Copilot CLI、Copilot coding agent、VS Code Insiders で共通利用可能
5. **フォールバック**: Copilot CLI が利用不可の場合、従来の動的 `read_file` 読み込みにフォールバック

#### 各アプローチの比較

| 観点 | Copilot CLI セッション分離 | 動的 `read_file`（フォールバック） | Extension API |
| ------ | ----------------------- | --------------------------------- | ------------- |
| 導入コスト | 低（シェルスクリプト） | 低（Markdownのみ） | 高（TypeScript） |
| セッション分離 | 完全分離 | 不可（単一セッション） | 完全分離 |
| 並列実行 | 可能 | 不可 | 可能 |
| コンテキスト効率 | 高（結果のみ読み込み） | 中（スキル定義も読み込み） | 高 |
| プレミアムリクエスト | スキル数分消費 | 1リクエスト | 1リクエスト |
| 推奨用途 | チーム開発、CI統合 | Copilot CLI 未導入環境 | 高度なカスタム |

### 6.3 スキル選択の自動化

Review Routerは、変更内容に基づいて実行するスキルを自動選択します。

#### 必須スキル（常に実行）

| スキル | 目的 |
| -------- | ------ |
| Code Review | バグ検出、ガイドライン準拠チェック（信頼度80以上のみ報告） |
| Error Handler Hunt | サイレント失敗の検出、空catchブロックの禁止 |

#### 条件付きスキル（変更内容に応じて実行）

| スキル | 実行条件 | 目的 |
| -------- | ---------- | ------ |
| Test Analysis | `*.test.ts`, `*.spec.ts` の追加・変更 | 動作カバレッジの分析、テストギャップの特定 |
| Type Design Analysis | `interface`, `type`, `class` の追加・変更 | 型カプセル化、不変性の評価 |
| Comment Analysis | JSDoc、コメント、README の変更 | コメントと実コードの整合性確認 |
| Code Simplification | 30行超の関数、3段以上のネスト | 不要な複雑性の排除 |

#### 統合レポートの判定基準

| 判定 | 意味 | 対応 |
| ------ | ------ | ------ |
| `PASS` | 問題なし | マージ可能 |
| `NEEDS_WORK` | 改善推奨の問題あり | 修正後に再レビュー |
| `CRITICAL_BLOCK` | 重大な問題あり | 必ず修正が必要 |

### 6.4 使用方法

#### 方法1: VS Code Chat から実行（推奨）

PR作成後、VS Code の Copilot Chat で以下を入力するだけで、Copilot CLI によるセッション分離レビューが自動実行されます。

```text
@review-router このPRをレビューして
```

特定スキルのみ実行する場合：

```text
@review-router テスト分析だけ
@review-router 型設計を分析して
```

#### 方法2: ターミナルから直接実行

**macOS / Linux:**

```bash
# 必須スキルのみ（自動判定で条件付きスキルも追加）
bash scripts/review.sh

# 全スキル実行
bash scripts/review.sh --all

# 全スキル並列実行
bash scripts/review.sh --all --parallel

# 特定スキルのみ
bash scripts/review.sh --skill code-review --skill test-analysis
```

**Windows (PowerShell):**

```powershell
# 必須スキルのみ（自動判定で条件付きスキルも追加）
.\scripts\review.ps1

# 全スキル実行
.\scripts\review.ps1 -All

# 全スキル並列実行
.\scripts\review.ps1 -All -Parallel

# 特定スキルのみ（カンマ区切り）
.\scripts\review.ps1 -Skill code-review,test-analysis
```

結果は `.review-results/` ディレクトリに出力されます。

#### 方法3: Copilot CLI のインタラクティブモード

Copilot CLI は Agent Skills（`.github/skills/*/SKILL.md`）を自動検出するため、プロンプト内容に応じて適切なスキルが自動適用されます。

```bash
copilot
> このPRの変更をレビューして
```

#### Git Workflowへの統合

AI仕様駆動開発の Git Workflow に以下のステップとして統合されています：

```text
Issue → Branch → Commit → Self-Review → PR → @review-router → Review → Merge
```

詳細は [git-workflow.md](../docs-template/05-operations/deployment/git-workflow.md) のステップ3.5を参照してください。

#### セットアップ

##### 必須（VS Code Chat）

1. VS Code 1.107 以降と GitHub Copilot 拡張機能が必要
2. `.github/agents/review-router.agent.md` をリポジトリに配置
3. `settings.json` に以下を追加：

```json
{
  "github.copilot.chat.cli.customAgents.enabled": true
}
```

##### 推奨（Copilot CLI セッション分離）

4. Copilot CLI のインストール：

```bash
# macOS / Linux
brew install copilot-cli

# Windows
winget install GitHub.Copilot
# または
scoop install copilot-cli
```

5. `.github/skills/` ディレクトリに Agent Skills を配置（本リポジトリに同梱済み）
6. スクリプトの準備：

```bash
# macOS / Linux
chmod +x scripts/review.sh

# Windows は特別な準備不要（PowerShell で直接実行可能）
# ただし実行ポリシーの制限がある場合:
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

7. `.gitignore` に結果ディレクトリを追加：

```text
.review-results/
```

### 6.5 Claude Code pr-review-toolkit との比較

AI仕様駆動開発では、Claude Code と GitHub Copilot の両方でレビュー自動化を実現しています。

| 観点 | Claude Code (pr-review-toolkit) | GitHub Copilot (Review Router) |
| ------ | ------ | ------ |
| アーキテクチャ | 独立スキル型（各スキルが独立） | ルーター + Copilot CLI セッション分離 |
| スキル選択 | 手動（各スキルを個別呼び出し） | 自動（スクリプトが変更内容から判定） |
| 呼び出し方法 | `/review` コマンド | `@review-router` エージェント |
| セッション分離 | 各スキルが独立セッション | 各 `copilot -p` が独立セッション |
| 統合レポート | なし（個別出力） | あり（1つに集約） |
| 並列実行 | 不可 | 可能（`--parallel`） |
| コンテキスト効率 | 実行スキル分のみ消費 | 結果ファイルのみ読み込み（最高効率） |
| カスタマイズ | スキル定義ファイルを編集 | `.github/skills/` 配下の SKILL.md を編集 |

**どちらを使うべきか**：
- **Claude Code** を主に使う場合 → `pr-review-toolkit` の各スキルを活用
- **GitHub Copilot** を主に使う場合 → `@review-router` でワンコマンドレビュー
- **両方を使う場合** → 各ツールのレビュースキルが同じ基準（MASTER.md, PATTERNS.md）を参照するため、結果の一貫性が保たれる

## 7. AIツール設定ファイルのベストプラクティス

AIツール設定ファイル（CLAUDE.md、AGENTS.md、copilot-instructions.md、.cursorrules）には、コーディング規約だけでなく **運用プロセス全体のルール** を記載することで、AIの作業品質が大幅に向上します。

実プロダクト開発の経験から特に効果が高いのは以下の実践です:

- **作業スタイルの定義** — AIの報告形式・説明の仕方を統一
- **Git Workflowの記載** — ブランチ命名・コミット形式・PRルールを設定ファイル内に明記
- **セルフレビューチェックリスト** — PR作成前の必須確認項目
- **スコープ外問題の取り扱い** — 発見した問題の即Issue作成ルール
- **Automated Hooks情報** — Git hookやCIの存在をAIに伝える

これらのベストプラクティスは、CLAUDE.mdだけでなくAGENTS.mdやcopilot-instructions.mdにも同様に適用できます。

詳細は [AIツール設定ファイルのベストプラクティス](AI_CONFIG_BEST_PRACTICES.md) を参照してください。
