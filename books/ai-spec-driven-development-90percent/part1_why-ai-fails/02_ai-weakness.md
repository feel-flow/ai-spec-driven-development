# 第2章　AIが苦手なのは"コーディング"ではなく"心を読むこと"

## この章で学ぶこと

- LLMが得意な領域と苦手な領域を正確に理解する
- 「未記述要件の補完」がなぜ危険なのか
- 仮定を排除して仕様を渡す方法論

---

## LLMが強い領域：既知パターンの組み立て

### コーディング能力は本物

まず明確にしておきたいのは、**LLMのコーディング能力は非常に高い**ということです。

以下のようなタスクでは、人間を凌駕するスピードと正確さを発揮します：

1. **既知のパターンの実装**
   - CRUD操作
   - 認証・認可の標準的な実装
   - デザインパターンの適用
   - ライブラリの標準的な使い方

2. **コードの変換・リファクタリング**
   - 言語間の変換（Python → TypeScript）
   - フレームワーク間の移行（Express → Fastify）
   - レガシーコードのモダナイズ

3. **ボイラープレートの生成**
   - 設定ファイル
   - テストの雛形
   - CIパイプラインの設定

4. **明確な仕様に基づく実装**
   - 「この入力でこの出力を返す関数」
   - 「このAPIスキーマに従ったエンドポイント」
   - 「このテストケースをパスする実装」

### なぜ強いのか

LLMは、膨大な量のコードを学習しています。

GitHub上の何百万ものリポジトリ、Stack Overflowの質問と回答、技術ドキュメント、ブログ記事——これらすべてから「こういう要件にはこういう実装」というパターンを学習しています。

そのため、**すでに世の中に存在するパターン**であれば、高い精度で再現できます。

---

## LLMが弱い領域：未記述要件の補完

### 「書かれていないこと」への対処

LLMが苦手なのは、**書かれていない要件を正しく補完すること**です。

例を見てみましょう。

```
指示：「ユーザー登録APIを作って」

AIが推測しなければならないこと：
- パスワードの最小文字数は？（8文字？12文字？）
- メールアドレスの重複チェックは？（どのタイミングで？）
- ユーザー名の使用可能文字は？（英数字のみ？日本語OK？）
- 登録後に確認メールを送る？（即時アクティブ？）
- どのエラーコードを返す？（400？409？422？）
- レスポンスに何を含める？（ID？作成日時？トークン？）
```

これらの情報が指示に含まれていなければ、AIは**「一般的にはこうだろう」という推測**で実装します。

その推測が、あなたのプロジェクトの要件と一致する保証はどこにもありません。

### 勝手な仮定の危険性

AIが置く「勝手な仮定」は、しばしば発見が遅れます。

```typescript
// AIが書いたコード
async function registerUser(email: string, password: string) {
  // AIの仮定：パスワードは8文字以上でよいだろう
  if (password.length < 8) {
    throw new Error('Password must be at least 8 characters');
  }

  // AIの仮定：メールの重複チェックは先にやるべきだろう
  const existing = await db.user.findByEmail(email);
  if (existing) {
    throw new Error('Email already exists');
  }

  // AIの仮定：パスワードはbcryptでハッシュ化するだろう
  const hashed = await bcrypt.hash(password, 10);

  // AIの仮定：作成日時は自動で入るだろう
  return db.user.create({ email, password: hashed });
}
```

このコードは動きます。一見、問題ないように見えます。

しかし：

- 会社のセキュリティポリシーは「12文字以上、英数字記号混在」かもしれない
- 既存システムではArgon2を使っているかもしれない
- ユーザー名も必須かもしれない
- 監査ログを書く要件があるかもしれない

**動くコードが、正しいコードとは限らない**のです。

### 推測の連鎖

一つの推測が、次の推測を呼びます。

```
「認証API」→ JWT使うだろう → RS256だろう → 公開鍵はどこに置く？ → 環境変数だろう
         → トークンの有効期限は？ → 1時間だろう → リフレッシュトークンは？ → いるだろう
         → どこに保存する？ → Cookieだろう → httpOnlyだろう → SameSiteは？ → Strictだろう
```

すべてが推測の上に推測を重ねた構造になります。

この推測の連鎖のどこかがプロジェクトの要件と違っていれば、大きな手戻りが発生します。

---

## 解法：仮定を排除して、仕様を"書いてから"渡す

### 「仮定させない」という発想

AIに「勝手に仮定するな」と言っても無駄です。情報がなければ、仮定するしかありません。

解決策は、**仮定する余地をなくすこと**です。

つまり、**仕様を書いてから渡す**。

### 良い仕様の例

先ほどのユーザー登録APIを、仕様として書き直してみましょう。

```markdown
## ユーザー登録API

### エンドポイント
POST /api/v1/users

### リクエスト
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss123",
  "username": "johndoe"
}
```

### バリデーションルール
- email: 有効なメールアドレス形式、255文字以内
- password: 12文字以上、英大文字・小文字・数字・記号を各1つ以上含む
- username: 3-30文字、英数字とアンダースコアのみ

### 重複チェック
- email: 重複時は409 Conflictを返す
- username: 重複時は409 Conflictを返す

### パスワードハッシュ
- アルゴリズム: Argon2id
- メモリコスト: 65536
- 時間コスト: 3
- 並列度: 4

### レスポンス（成功時）
- ステータス: 201 Created
- ボディ:
```json
{
  "id": "uuid",
  "email": "user@example.com",
  "username": "johndoe",
  "createdAt": "2024-01-01T00:00:00Z"
}
```

### レスポンス（エラー時）
- 400 Bad Request: バリデーションエラー
- 409 Conflict: メールまたはユーザー名の重複
- 500 Internal Server Error: サーバーエラー

### 監査ログ
- 登録成功時: audit.log に USER_CREATED イベントを記録
- 登録失敗時: audit.log に USER_REGISTRATION_FAILED イベントを記録

### 既存コードとの関係
- バリデーション: src/validators/user.ts の validateUserInput を使用
- エラーレスポンス: src/errors/http.ts の形式に従う
- 監査ログ: src/services/audit.ts の AuditService を使用
```

この仕様をAIに渡せば、**推測の余地がほとんどなくなります**。

### 仕様に含めるべき情報

最低限、以下の情報を含めましょう。

| カテゴリ | 含めるべき情報 |
|---------|--------------|
| What | 何を作るのか、何を作らないのか |
| How | どう実装するのか（アルゴリズム、使用ライブラリ） |
| Where | 既存コードのどこに配置するのか |
| Constraint | 制約条件（パフォーマンス、セキュリティ） |
| Format | 入出力の形式（スキーマ、エラーレスポンス） |
| Test | 正しさの判定基準（テストケース、受け入れ条件） |

### Issue = 最小の仕様書

「仕様を書く」と聞くと重厚長大なドキュメントを想像するかもしれませんが、その必要はありません。

**Issue（課題チケット）が最小の仕様書**になります。

```markdown
## Issue #42: ユーザー登録API の実装

### 背景
新規ユーザー登録機能を実装する。セキュリティポリシーに準拠した
パスワード要件を満たすこと。

### 受け入れ基準
- [ ] POST /api/v1/users でユーザーを作成できる
- [ ] パスワードは12文字以上、英大文字・小文字・数字・記号必須
- [ ] メール・ユーザー名の重複時は409を返す
- [ ] 成功時は201と作成されたユーザー情報を返す
- [ ] 監査ログにイベントが記録される

### 技術的制約
- パスワードハッシュはArgon2id（既存の hashService を使用）
- エラーレスポンスは src/errors/http.ts の形式に従う

### スコープ外
- メール確認フローは別Issue（#43）で対応
- ソーシャルログインは別Issue（#44）で対応
```

この程度の情報があれば、AIは「仮定」をほとんど置かずに実装できます。

---

## 章末チェックリスト

- [ ] 最近AIに出した指示を振り返り、「推測が必要だった箇所」を特定する
- [ ] 次にAIに指示を出すとき、What/How/Where/Constraint/Format/Testを意識する
- [ ] Issueテンプレートを作成し、「受け入れ基準」「技術的制約」「スコープ外」の項目を入れる

---

## 次章への橋渡し

この章では、LLMの得意・不得意を理解し、「仮定を排除する」ための仕様の書き方を学びました。

次章からは、この「仕様」をプロジェクト全体で体系化する方法——**7文書構成**——に入っていきます。単発の仕様ではなく、プロジェクト全体を通じてAIが参照できる「生きた仕様」の作り方を解説します。
