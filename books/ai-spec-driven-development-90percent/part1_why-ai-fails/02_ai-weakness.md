# 第2章　AIが苦手なのは"コーディング"ではなく"心を読むこと"

## この章で学ぶこと

- LLMが得意な領域と苦手な領域を正確に理解する
- 「未記述要件の補完」がなぜ危険なのか
- 仮定を排除して仕様を渡す方法論

---

## LLMが強い領域：既知パターンの組み立て

### コーディング能力は本物

まず明確にしておきたいのは、**LLMのコーディング能力は非常に高い** ということです。

以下のようなタスクでは、人間を凌駕するスピードと正確さを発揮します：

1. **既知のパターンの実装**
   - CRUD操作
   - 認証・認可の標準的な実装
   - デザインパターンの適用
   - ライブラリの標準的な使い方

2. **コードの変換・リファクタリング**
   - 言語間の変換（Python → TypeScript）
   - フレームワーク間の移行（Express → Fastify）
   - レガシーコードのモダナイズ

3. **ボイラープレートの生成**
   - 設定ファイル
   - テストの雛形
   - CIパイプラインの設定

4. **明確な仕様に基づく実装**
   - 「この入力でこの出力を返す関数」
   - 「このAPIスキーマに従ったエンドポイント」
   - 「このテストケースをパスする実装」

### なぜ強いのか

LLMは、膨大な量のコードを学習しています。

GitHub上の何百万ものリポジトリ、Stack Overflowの質問と回答、技術ドキュメント、ブログ記事——これらすべてから「こういう要件にはこういう実装」というパターンを学習しています。

そのため、**すでに世の中に存在するパターン** であれば、高い精度で再現できます。

---

## LLMが弱い領域：未記述要件の補完

### 「書かれていないこと」への対処

LLMが苦手なのは、**書かれていない要件を正しく補完すること** です。

例を見てみましょう。

```
指示：「ユーザー登録APIを作って」

AIが推測しなければならないこと：
- パスワードの最小文字数は？（8文字？12文字？）
- メールアドレスの重複チェックは？（どのタイミングで？）
- ユーザー名の使用可能文字は？（英数字のみ？日本語OK？）
- 登録後に確認メールを送る？（即時アクティブ？）
- どのエラーコードを返す？（400？409？422？）
- レスポンスに何を含める？（ID？作成日時？トークン？）
```

これらの情報が指示に含まれていなければ、AIは**「一般的にはこうだろう」という推測** で実装します。

その推測が、あなたのプロジェクトの要件と一致する保証はどこにもありません。

### 勝手な仮定の危険性

AIが置く「勝手な仮定」は、しばしば発見が遅れます。

```typescript
// AIが書いたコード
async function registerUser(email: string, password: string) {
  // AIの仮定：パスワードは8文字以上でよいだろう
  if (password.length < 8) {
    throw new Error('Password must be at least 8 characters');
  }

  // AIの仮定：メールの重複チェックは先にやるべきだろう
  const existing = await db.user.findByEmail(email);
  if (existing) {
    throw new Error('Email already exists');
  }

  // AIの仮定：パスワードはbcryptでハッシュ化するだろう
  const hashed = await bcrypt.hash(password, 10);

  // AIの仮定：作成日時は自動で入るだろう
  return db.user.create({ email, password: hashed });
}
```

このコードは動きます。一見、問題ないように見えます。

しかし：

- 会社のセキュリティポリシーは「12文字以上、英数字記号混在」かもしれない
- 既存システムではArgon2を使っているかもしれない
- ユーザー名も必須かもしれない
- 監査ログを書く要件があるかもしれない

**動くコードが、正しいコードとは限らない** のです。

### 推測の連鎖

一つの推測が、次の推測を呼びます。

```
「認証API」→ JWT使うだろう → RS256だろう → 公開鍵はどこに置く？ → 環境変数だろう
         → トークンの有効期限は？ → 1時間だろう → リフレッシュトークンは？ → いるだろう
         → どこに保存する？ → Cookieだろう → httpOnlyだろう → SameSiteは？ → Strictだろう
```

すべてが推測の上に推測を重ねた構造になります。

この推測の連鎖のどこかがプロジェクトの要件と違っていれば、大きな手戻りが発生します。

#### 推測連鎖の可視化

推測の連鎖は、実際のコードレビューで発覚するまで見えにくいものです。しかし、AIに「あなたが置いた仮定を列挙して」と聞くことで可視化できます。

あるプロジェクトで試してみた結果を紹介します。「ユーザー認証機能を実装して」という指示に対して、AIが置いた仮定を確認したところ、17個の仮定が見つかりました。

- 認証方式に関する仮定（JWT、有効期限、リフレッシュトークン）：5個
- セキュリティに関する仮定（ハッシュアルゴリズム、ソルト、CSRF対策）：4個
- ストレージに関する仮定（トークンの保存場所、セッション管理）：3個
- エラーハンドリングに関する仮定（レスポンス形式、ログ出力）：3個
- UIに関する仮定（リダイレクト先、エラー表示）：2個

このうち、プロジェクトの要件と一致していたのは9個でした。残りの8個は修正が必要でした。

推測の可視化を習慣にすることで、「どの程度の仕様を明示すれば推測を減らせるか」が感覚としてわかるようになります。最初は面倒に感じますが、手戻りを大幅に減らせるため、結果的には時間の節約になります。

---

## 技術バージョン：もう一つの「未記述要件」

### AIの学習データには締め切りがある

LLMにはもう一つ、見落とされがちな弱点があります。

それは**学習データのカットオフ（知識の締め切り日）** です。

LLMは特定の日付までのデータで学習されています。

- Claude Sonnet 4：2025年3月頃
- Claude Sonnet 4.5：2025年7月頃（信頼性が高いのは2025年1月まで）
- GPT-4o：2024年6月頃
- GPT-5：2024年10月頃
- Gemini 2.5 Pro：2025年1月末頃

つまり、**カットオフ以降にリリースされた技術については、古い情報しか持っていない**可能性があります。

### バージョンを書かないとどうなるか

```
指示：「Next.jsでApp Routerを使ってAPIルートを作って」

AIが推測すること：
- Next.jsのバージョンは？（13.4？14.0？15.0？）
- 各バージョンでAPIルートの書き方が微妙に違う
- App Routerはいつから安定版？
```

バージョンを明記しなければ、AIは「学習時点で一般的だったバージョン」を想定します。

結果として：

- **非推奨APIを使ったコードが生成される**
- **新しいバージョンでは動かない書き方が提案される**
- **セキュリティパッチが適用される前の脆弱な実装パターンが使われる**

### 実際に起きる問題

Next.jsを例に見てみましょう。

```typescript
// AIが書いたコード（Next.js 13.x想定）
// pages/api/users.ts ← Pages Routerの書き方
export default function handler(req, res) {
  res.status(200).json({ users: [] });
}
```

```typescript
// 実際のプロジェクト（Next.js 15.x）では
// app/api/users/route.ts ← App Routerの書き方
export async function GET() {
  return Response.json({ users: [] });
}
```

ディレクトリ構造も、エクスポート形式も、レスポンスの返し方も、まったく異なります。

AIが古い書き方で実装すると、プロジェクトの構成と合わず、すべて書き直しになります。

### Reactでも同様の問題

```typescript
// AIが書いたコード（React 18想定）
// クライアントコンポーネントとして全体を実装
'use client';
import { useState, useEffect } from 'react';

export default function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('/api/users').then(r => r.json()).then(setUsers);
  }, []);

  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

```typescript
// React 19 + Next.js 15では
// Server Componentとしてシンプルに実装
export default async function UserList() {
  const users = await fetch('/api/users').then(r => r.json());
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

Server Componentsを知らないAIは、不要な`'use client'`を付け、`useEffect`で無理やりデータを取得します。

### 解決策：技術スタックにバージョンを明記する

MASTER.mdやARCHITECTURE.mdで、**使用する技術とバージョンを明示**します。

```markdown
## 技術スタック

| 技術 | バージョン | AIへの注意点 |
|------|-----------|-------------|
| Next.js | 16.1.x | App Router使用（Pages Router禁止） |
| React | 19.2.x | Server Componentsがデフォルト |
| TypeScript | 5.9.x | strict mode有効 |
| PostgreSQL | 17.x | - |
| Prisma | 6.x | - |
```

この情報があれば、AIは：

- 「Next.js 16ではApp Routerでこう書く」と正しく実装
- 「React 19.2のServer Componentsを活用した設計」を提案
- 「TypeScript 5.9の新機能を使用可能」と判断

**バージョンを書くことは、AIへの「追加の仕様」** なのです。

### なぜADRが必要か

さらに重要なのは、** なぜその技術・バージョンを選んだのか** を記録することです。

これを**ADR（Architecture Decision Record）** と呼びます。

ADRがあると：

- **AIが技術選定の背景を理解**し、一貫した設計提案ができる
- **後から参加したメンバー** が「なぜこの技術？」を理解できる
- **将来の変更時** に「当時の判断根拠」を参照できる

ADRの詳細な書き方は、第4章のARCHITECTURE.mdセクションで解説します。

#### ADRが解決する具体的な問題

ADRがない状態で起きた実際の問題を紹介します。

あるプロジェクトで、APIの認証方式がJWTで実装されていました。新機能を追加する際、AIに「管理者向けAPIを実装して」と依頼したところ、セッションベースの認証で実装されました。

AIは「管理者向け」という言葉から、「より厳格なセキュリティが必要」と推測し、セッション認証の方が適切と判断したのです。しかし、このプロジェクトでは「マイクロサービス間の呼び出しを考慮してJWTを採用」という設計判断があり、管理者向けAPIもJWTで統一すべきでした。

問題は、この設計判断がどこにも書かれていなかったことです。元々の開発者は「当然JWTで統一だろう」と思っていましたが、AIにとっては「当然」ではありませんでした。

ADRに「認証はJWTを採用、理由はマイクロサービス間の認証を統一するため。セッション認証は使用しない」と書かれていれば、AIはこの判断を尊重し、管理者向けAPIもJWTで実装したはずです。

技術選定の背景を記録するだけで、このような「暗黙の了解」による不整合を防げます。

---

## 解法：仮定を排除して、仕様を"書いてから"渡す

### 「仮定させない」という発想

AIに「勝手に仮定するな」と言っても無駄です。情報がなければ、仮定するしかありません。

解決策は、**仮定する余地をなくすこと** です。

つまり、**仕様を書いてから渡す**。

### 良い仕様の例

先ほどのユーザー登録APIを、仕様として書き直してみましょう。

```markdown
## ユーザー登録API

### エンドポイント
POST /api/v1/users

### リクエスト
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss123",
  "username": "johndoe"
}
```

### バリデーションルール
- email: 有効なメールアドレス形式、255文字以内
- password: 12文字以上、英大文字・小文字・数字・記号を各1つ以上含む
- username: 3-30文字、英数字とアンダースコアのみ

### 重複チェック
- email: 重複時は409 Conflictを返す
- username: 重複時は409 Conflictを返す

### パスワードハッシュ
- アルゴリズム: Argon2id
- メモリコスト: 65536
- 時間コスト: 3
- 並列度: 4

### レスポンス（成功時）
- ステータス: 201 Created
- ボディ:
```json
{
  "id": "uuid",
  "email": "user@example.com",
  "username": "johndoe",
  "createdAt": "2026-01-01T00:00:00Z"
}
```

### レスポンス（エラー時）
- 400 Bad Request: バリデーションエラー
- 409 Conflict: メールまたはユーザー名の重複
- 500 Internal Server Error: サーバーエラー

### 監査ログ
- 登録成功時: audit.log に USER_CREATED イベントを記録
- 登録失敗時: audit.log に USER_REGISTRATION_FAILED イベントを記録

### 既存コードとの関係
- バリデーション: src/validators/user.ts の validateUserInput を使用
- エラーレスポンス: src/errors/http.ts の形式に従う
- 監査ログ: src/services/audit.ts の AuditService を使用
```

この仕様をAIに渡せば、**推測の余地がほとんどなくなります**。

### 仕様に含めるべき情報

最低限、以下の情報を含めましょう。

| カテゴリ | 含めるべき情報 |
|---------|--------------|
| What | 何を作るのか、何を作らないのか |
| How | どう実装するのか（アルゴリズム、使用ライブラリ） |
| Where | 既存コードのどこに配置するのか |
| Constraint | 制約条件（パフォーマンス、セキュリティ） |
| Format | 入出力の形式（スキーマ、エラーレスポンス） |
| Test | 正しさの判定基準（テストケース、受け入れ条件） |

### Issue = 最小の仕様書

「仕様を書く」と聞くと重厚長大なドキュメントを想像するかもしれませんが、その必要はありません。

**Issue（課題チケット）が最小の仕様書** になります。

```markdown
## Issue #42: ユーザー登録API の実装

### 背景
新規ユーザー登録機能を実装する。セキュリティポリシーに準拠した
パスワード要件を満たすこと。

### 受け入れ基準
- [ ] POST /api/v1/users でユーザーを作成できる
- [ ] パスワードは12文字以上、英大文字・小文字・数字・記号必須
- [ ] メール・ユーザー名の重複時は409を返す
- [ ] 成功時は201と作成されたユーザー情報を返す
- [ ] 監査ログにイベントが記録される

### 技術的制約
- パスワードハッシュはArgon2id（既存の hashService を使用）
- エラーレスポンスは src/errors/http.ts の形式に従う

### スコープ外
- メール確認フローは別Issue（#43）で対応
- ソーシャルログインは別Issue（#44）で対応
```

この程度の情報があれば、AIは「仮定」をほとんど置かずに実装できます。

---

## 章末チェックリスト

- [ ] 最近AIに出した指示を振り返り、「推測が必要だった箇所」を特定する
- [ ] 次にAIに指示を出すとき、What/How/Where/Constraint/Format/Testを意識する
- [ ] Issueテンプレートを作成し、「受け入れ基準」「技術的制約」「スコープ外」の項目を入れる
- [ ] プロジェクトで使用している主要技術のバージョンを確認する
- [ ] AIが未学習の可能性がある新しい技術を特定する
- [ ] 技術バージョンをMASTER.mdまたはARCHITECTURE.mdに明記する

---

## 次章への橋渡し

この章では、LLMの得意・不得意を理解し、「仮定を排除する」ための仕様の書き方を学びました。

次章からは、この「仕様」をプロジェクト全体で体系化する方法——**7文書構成**——に入っていきます。単発の仕様ではなく、プロジェクト全体を通じてAIが参照できる「生きた仕様」の作り方を解説します。
