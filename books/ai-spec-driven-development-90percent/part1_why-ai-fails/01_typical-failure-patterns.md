# 第1部　なぜ「AI任せ」は失敗するのか

![第1部：なぜAI任せは失敗するのか](../images/part1-why-ai-fails.jpeg)

「AIに任せれば楽になる」——その期待が裏切られる原因を解明します。vibe codingの限界、PRの肥大化、そしてAIが本当に苦手なこと。失敗パターンを知ることが、成功への第一歩です。

---

# 第1章　AIに全部任せようとして事故る典型パターン

## この章で学ぶこと

- "vibe coding"が破綻する瞬間を理解する
- PRが巨大化・レビュー不能になるメカニズム
- 「AIが賢くない」のではなく「入力が仕様になっていない」という本質

---

## "vibe coding"が破綻する瞬間

### 「なんとなく」で始まる開発

AIコーディングツールを使い始めたエンジニアが最初にやりがちなのが、 **"vibe coding"** です。

```
「なんかいい感じにユーザー認証作って」
「このAPIをRESTfulに直して」
「エラーハンドリングをいい感じに」
```

「いい感じ」「なんとなく」——この曖昧な指示でも、AIは何かを生成します。そして、その生成されたコードは、一見すると動いているように見えます。

**ここが罠です。**

### 暗黙知の推測ゲーム

vibe codingが破綻するのは、**AIが暗黙知を推測し始める瞬間** です。

あなたのプロジェクトには、明文化されていないルールがたくさんあります。

- 「認証はJWTを使う」（どこにも書いていない）
- 「エラーレスポンスはこの形式」（過去のコードを見ればわかる）
- 「この関数は非同期で呼ばれる前提」（設計時の暗黙の了解）
- 「テストはこのパターンで書く」（チームの慣習）

AIはこれらを**知りません**。

知らないから、推測します。推測は、プロジェクトの文脈と乖離します。乖離したコードは、レビューで弾かれるか、より悪いケースでは本番で事故を起こします。

### 破綻のシグナル

vibe codingが限界に達したときに現れるシグナル：

1. **「なんでこうなった？」が増える**
   - コードの意図が読めない
   - AIの判断根拠が不明
   - 修正しようにも、どこを直せばいいかわからない

2. **レビューコメントが膨大になる**
   - 「ここ、うちのプロジェクトではこう書く」の連発
   - 同じ指摘が何度も繰り返される

3. **「もう一度書いて」が頻発する**
   - 微調整では済まず、全面書き直しになる
   - 結局、手で書いた方が早かった

#### 実際に起きた失敗事例

あるチームで、「決済画面のUIを改善して」という指示でAIにコードを生成させました。AIは見た目の良いUIを生成しましたが、3つの問題が発生しました。

1つ目は、既存のデザインシステムを無視したことです。プロジェクトにはコンポーネントライブラリがありましたが、AIはそれを知らず、独自のスタイルを生成しました。結果、他の画面と統一感のないUIになりました。

2つ目は、アクセシビリティ要件を満たしていなかったことです。このプロジェクトではWCAG 2.1 AAに準拠する必要がありましたが、AIが生成したコードはコントラスト比やキーボードナビゲーションの要件を満たしていませんでした。

3つ目は、エラーハンドリングが不十分だったことです。決済エラー時の表示が「エラーが発生しました」という汎用メッセージだけで、カード番号の誤りなのか、残高不足なのか、ネットワークエラーなのか、ユーザーには区別できませんでした。

これらの問題は、「UIを改善」という曖昧な指示に、デザインシステムの参照、アクセシビリティ要件、エラーハンドリング方針が含まれていなかったことが原因です。

---

## PRが巨大化する／レビュー不能になる／仕様が消える

### なぜPRは巨大化するのか

「ログイン機能を作って」——この一言で、AIは何を作るでしょうか？

- ログインフォームのUI
- バリデーションロジック
- API呼び出し
- 認証トークンの保存
- エラーハンドリング
- 成功時のリダイレクト
- ログアウト機能も「あった方がいいだろう」と追加
- パスワードリセット機能も「普通はあるよね」と追加

1つの指示から、**関連しそうなもの全部** を生成しようとします。

結果、PRは何百行、何千行にもなります。

### レビュー不能のメカニズム

巨大なPRがレビュー不能になる理由は単純です。

**人間がレビューできる限界は、1回あたり200〜400行程度** と言われています。

それを超えると：
- 細部を見落とす
- 「まあ動いてるからいいか」という妥協が生まれる
- セキュリティホールやパフォーマンス問題が見逃される

また、巨大なPRは**変更の意図を追跡できなくなります**。

「なぜこのファイルが変更されているのか」
「この変更は本当に必要だったのか」
「別の方法はなかったのか」

これらの問いに答えられないPRは、レビューしようがありません。

### 仕様が消える

最も深刻な問題は、**仕様が消える**ことです。

AIに「ログイン機能を作って」と言ったとき、その仕様はどこにありますか？

- チャットログの中？（1週間後には埋もれる）
- あなたの頭の中？（共有されていない）
- なんとなくの合意？（明文化されていない）

仕様が明文化されていなければ、**何が正しいのか判断できません**。

- このバリデーションルールは正しいのか？
- エラーメッセージの文言は意図通りか？
- リダイレクト先はこれでよかったのか？

レビュワーも、実装者も、後から見た人も、誰も判断できない。

これが「仕様が消える」という状態です。

#### 仕様消失がもたらす具体的なコスト

仕様が消えることの影響を、ある開発チームの実測値で示します。

このチームでは、仕様が明文化されていない機能についてバグ報告があったとき、平均して以下の時間がかかっていました。

- **仕様の確認**：45分（Slackの過去ログを検索、関係者に確認）
- **「正しい動作」の合意形成**：30分（複数人で議論）
- **修正の実装**：20分（実際のコード変更）
- **レビュー**：15分

つまり、修正自体は20分で終わるのに、「何が正しいか」を確認するだけで75分かかっていました。修正時間の3.75倍です。

さらに深刻だったのは、同じ機能について異なる解釈で実装されたケースです。AさんとBさんが別々のPRで同じ機能に触れ、それぞれ異なる「正しい動作」を想定して実装しました。結果、本番で矛盾した動作が発生し、緊急対応に4時間を要しました。

仕様を明文化するのに必要な時間は、1機能あたり30分程度です。この30分を惜しんで、何倍もの時間を無駄にしていたことになります。

---

## 「AIが賢くない」のではなく「入力が仕様になっていない」

### 責任の所在を正しく理解する

ここまでの問題を見て、「やっぱりAIはまだ使えない」と結論づけるのは早計です。

問題の構造を整理しましょう。

| 現象 | よくある誤解 | 本当の原因 |
|------|------------|-----------|
| 意図と違うコードが生成される | AIの理解力が低い | 意図が明示されていない |
| PRが巨大になる | AIが勝手に拡張する | スコープが定義されていない |
| 仕様と合わない | AIがプロジェクトを知らない | 仕様がAIに渡されていない |
| 同じミスを繰り返す | AIが学習しない | ナレッジがフィードバックされていない |

すべての原因は、**「入力」の問題** です。

### LLMの動作原理を思い出す

生成AIは、与えられた入力から「最も確率の高い続き」を生成します。

入力が曖昧なら、出力も曖昧になります。
入力がブレれば、出力もブレます。
入力に含まれていない情報は、推測するしかありません。

これはAIの限界ではなく、**AIの仕様** です。

### 入力を「仕様」にする

解決策は明確です。

**AIへの入力を「仕様」にする**。

仕様とは何か？

- 何を作るのか（要件）
- どう作るのか（設計制約）
- 何を作らないのか（スコープ外）
- 何が正しいのか（受け入れ基準）
- どこに置くのか（既存コードとの関係）

これらが明示されていれば、AIは推測する必要がありません。

推測が不要なら、ブレません。
ブレなければ、レビューも楽になります。
レビューが楽なら、品質も上がります。

---

## 章末チェックリスト

この章の内容を実践に移すためのチェックリスト：

- [ ] 自分の指示が「vibe coding」になっていないか振り返る
- [ ] 最近のPRサイズを確認し、200行を超えているものを特定する
- [ ] 仕様がチャットログにしか残っていないケースを洗い出す
- [ ] 「AIが悪い」と思った場面を、「入力が不十分だった」視点で再評価する

---

## 次章への橋渡し

この章では、AI活用が失敗する典型パターンを見てきました。

次章では、**なぜAIが「心を読めない」のか** をより深く理解します。LLMの得意・不得意を正確に把握することで、「何を明示すべきか」がクリアになります。
