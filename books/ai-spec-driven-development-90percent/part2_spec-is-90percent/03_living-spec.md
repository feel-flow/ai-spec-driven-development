![第2部：仕様が9割](../images/part2-spec-is-90percent.jpeg)

**［第2部］** 本書の核心です。AIが迷わず動くために必要な「7文書構成」を提示します。MASTER.md を中心に、PROJECT / ARCHITECTURE / DOMAIN / PATTERNS / TESTING / DEPLOYMENT の役割と連携を解説。仕様を「生きた成果物」として運用する方法を学びます。

---

# 第3章　仕様を"生きた成果物"にする

## この章で学ぶこと

- 静的ドキュメントから「生きた仕様」への転換
- 変更を「差分」ではなく「影響度」で扱う発想
- 仕様→設計→テスト→運用の連鎖を維持する方法

---

## 仕様＝合意の置き場所

### チャットログは仕様ではない

「あのとき Slack で決めたよね」
「PRのコメントに書いてあったはず」
「ミーティングで合意したじゃん」

これらは**仕様ではありません**。

なぜか？

1. **検索できない**：埋もれる、見つからない、探す時間がかかる
2. **変更履歴が追えない**：いつ、誰が、何を変えたかわからない
3. **AIが参照できない**：コンテキストとして渡せない

仕様とは、**参照可能な場所に置かれた、合意の記録** です。

### 仕様の条件

「これが仕様である」と言えるためには、以下の条件を満たす必要があります。

| 条件 | 説明 | 反例 |
|------|------|------|
| 参照可能 | いつでも誰でも見られる | Slackの過去ログ、会議の口頭合意 |
| バージョン管理 | 変更履歴が追える | 上書きされるWikiページ |
| 単一の真実 | 重複がない、矛盾がない | 複数のドキュメントに散在 |
| 機械可読 | AIやツールが読み取れる | スキャンされたPDF、画像 |

#### 他のフォーマットを選ばなかった理由

仕様管理には様々なツールやフォーマットがあります。なぜMarkdownを選んだのか、他の選択肢との比較で説明します。

**Notion / Confluence**：リッチなUIで編集しやすい一方、バージョン管理が弱点です。「いつ、誰が、何を変えたか」の追跡が難しく、複数人が同時編集すると競合が発生します。また、AIがコンテキストとして参照するためにはAPI連携が必要になり、セットアップの手間が増えます。

**Google Docs**：リアルタイムコラボレーションには優れていますが、構造化された情報の管理には向きません。見出しやリストのスタイルがドキュメントごとにバラバラになりがちで、機械的な処理が困難です。

**JIRA / Linear などのチケット管理ツール**：タスク管理には優れていますが、仕様の「全体像」を俯瞰するには不向きです。情報がチケット単位で分断され、「このプロジェクトの認証方式は何か」といった横断的な質問に答えにくくなります。

**専用の仕様管理ツール（Swagger、OpenAPIなど）**：APIドキュメントには最適ですが、ビジネスルールやアーキテクチャ決定を記述するには不十分です。

Markdownファイルをリポジトリに置く方式は、これらの課題をすべて解決します。Gitによる完璧なバージョン管理、PRによるレビューフロー、コードと同じリポジトリにあることでの参照しやすさ、そしてAIが直接読み取れるテキスト形式。シンプルですが、最も実用的な選択です。

この条件を満たす最もシンプルな形式が、**GitリポジトリにあるMarkdownファイル** です。

### なぜMarkdownか

- **バージョン管理**：Gitで変更履歴が完璧に追える
- **差分表示**：PRで変更点がレビューできる
- **構造化**：見出し、リスト、テーブルで情報を整理
- **AI親和性**：LLMが最も扱いやすいテキスト形式
- **ツール連携**：静的サイト生成、Lintチェックが可能

---

## 変更は「差分」ではなく「影響度」で扱う

### 差分思考の限界

従来の仕様変更管理は「差分」に注目します。

```
変更前：パスワードは8文字以上
変更後：パスワードは12文字以上

差分：文字数が8→12に変更
```

しかし、この「差分」だけ見ても、**影響の大きさはわかりません**。

### 影響度思考への転換

「何が変わったか」ではなく、「何に影響するか」を考えます。

```markdown
## 変更：パスワード最小文字数 8 → 12

### 影響度：HIGH

### 影響範囲
- [ ] フロントエンド：バリデーションメッセージ更新
- [ ] バックエンド：バリデーションロジック更新
- [ ] テスト：パスワードバリデーションのテストケース追加
- [ ] ドキュメント：API仕様書のパラメータ説明更新
- [ ] 既存ユーザー：パスワード変更時の新ルール適用（ログイン時は旧パスワード許容？）

### 確認事項
- [ ] 移行期間は設けるか？
- [ ] 既存ユーザーへの通知は必要か？
- [ ] 監査ログへの記録方法は？
```

これが **影響度評価（changeImpact）** の発想です。

### 影響度の3段階

変更を以下の3段階で分類します。

| 影響度 | 定義 | 例 | 対応 |
|--------|------|-----|------|
| LOW | 文言・スタイルの修正 | エラーメッセージの文言変更、コメント修正 | 単独で対応可能 |
| MEDIUM | 既存概念の拡張 | フィールドの追加、オプション機能の追加 | 関連文書の確認が必要 |
| HIGH | 概念の再定義・削除 | データモデルの変更、APIの破壊的変更 | 全関連文書のレビューが必要 |

HIGH変更のときは、**必ず立ち止まって**影響範囲を洗い出します。

#### HIGH変更の判断に迷うケース

影響度の分類は単純ではありません。「これはMEDIUMか、HIGHか？」と迷うケースがあります。いくつかの典型例と判断基準を示します。

##### ケース1：APIのレスポンス形式変更

レスポンスに新しいフィールドを追加するのはMEDIUMですが、既存フィールドの型を変更する（例：`string`から`number`へ）のはHIGHです。後方互換性が失われ、クライアント側のコード修正が必須になるためです。

##### ケース2：バリデーションルールの変更

緩める方向（例：8文字以上→6文字以上）はMEDIUMで済むことが多いですが、厳しくする方向（例：8文字以上→12文字以上）は既存データへの影響を考慮する必要があり、HIGHになることがあります。

##### ケース3：オプション機能のデフォルト値変更

デフォルト値が`false`から`true`に変わる場合、「オプションだから影響は少ない」と思いがちですが、既存ユーザーの挙動が変わるためHIGHです。

判断に迷ったときは、**「既存のユーザーやシステムに影響があるか」** を基準にします。新規のみに影響するならMEDIUM、既存にも影響するならHIGHです。そして、迷ったらHIGHとして扱う方が安全です。

---

## "仕様→設計→テスト→運用"の連鎖を切らない

### 連鎖が切れるとき

多くのプロジェクトで、こんな状況が起きています。

```
仕様：「ユーザーは商品を購入できる」
  ↓（連鎖）
設計：CartServiceで購入処理
  ↓（連鎖が切れる）
テスト：???（何をテストすべきかわからない）
  ↓（連鎖が切れる）
運用：???（何を監視すべきかわからない）
```

仕様が曖昧なまま設計に入り、設計が曖昧なままテストを書き、テストが曖昧なまま本番に出す。

この**連鎖の切断** が、品質問題の根本原因です。

### 連鎖を維持する方法

連鎖を維持するには、**各フェーズの成果物が次のフェーズの入力になる** ように設計します。

```
仕様（PROJECT.md / DOMAIN.md）
  ↓ 何を作るか、ビジネスルールは何か
設計（ARCHITECTURE.md）
  ↓ どう作るか、コンポーネント構成は
テスト（TESTING.md）
  ↓ 何が正しいか、どう検証するか
運用（DEPLOYMENT.md）
  ↓ どう監視するか、障害時にどう対応するか
```

### 具体例：購入機能の連鎖

**仕様（DOMAIN.md）**

```markdown
## 購入ルール

- ユーザーは在庫がある商品のみ購入できる
- 購入数量は1〜10個まで
- 購入時に在庫を減算する（楽観的ロック使用）
- 在庫不足時は購入を拒否する
```

**設計（ARCHITECTURE.md）**

```markdown
## 購入処理フロー

1. CartServiceが購入リクエストを受け取る
2. InventoryServiceで在庫確認（楽観的ロック取得）
3. OrderServiceで注文作成
4. InventoryServiceで在庫減算（ロック解放）
5. PaymentServiceで決済処理
6. NotificationServiceで確認メール送信

### 障害パターン
- 在庫確認後〜減算前に他ユーザーが購入：409 Conflict返却
- 決済失敗：在庫をロールバック
```

**テスト（TESTING.md）**

```markdown
## 購入機能のテストケース

### 正常系
- [ ] 在庫がある商品を1個購入できる
- [ ] 在庫がある商品を10個購入できる

### 異常系
- [ ] 在庫0の商品は購入できない（409）
- [ ] 11個以上の購入はバリデーションエラー（400）
- [ ] 購入途中で他ユーザーに在庫を取られた場合（409）

### 負荷テスト
- [ ] 同時100ユーザーの購入で在庫の整合性が保たれる
```

**運用（DEPLOYMENT.md）**

```markdown
## 購入機能の監視

### メトリクス
- purchase_success_rate: 購入成功率（目標: 99.9%）
- inventory_conflict_rate: 在庫競合率（警告: 5%超過）

### アラート
- 購入成功率が95%を下回ったら即座に通知
- 在庫競合率が10%を超えたら在庫データ確認

### 障害対応Runbook
- [購入失敗急増時の対応手順](./runbooks/purchase-failure.md)
```

この**連鎖が維持されている** から、AIは一貫した実装ができます。

---

## 章末チェックリスト

- [ ] 仕様がチャットログやWikiに散在していないか確認する
- [ ] 最近の仕様変更を「影響度」で分類してみる
- [ ] 仕様→設計→テスト→運用の連鎖が途切れている箇所を特定する
- [ ] 途切れている箇所を補完するドキュメントを作成する計画を立てる

---

## 次章への橋渡し

この章では、仕様を「生きた成果物」として維持する考え方を学びました。

次章では、この考え方を具体化した**7文書構成** を紹介します。どの情報をどの文書に置くか、7つの文書がどのように連携するか、詳細に解説します。

---

## 🥷 AI侍道場 - 生きた仕様の作り方

【AI侍】「この章で学んだ『生きた仕様』——その本質を斬ってみせよう」

【DJ町娘】「AI侍さん、『生きた仕様』って、普通の仕様と何が違うんですか？」

【AI侍】「**普通の仕様は『書かれた瞬間に古くなる』。生きた仕様は『変更されるたびに更新される』**——これが決定的な違いである」

【DJ町娘】「書かれた瞬間に古くなる...？」

【AI侍】「うむ。チャットログに『こう作ろう』と書いた。だが実装時に『やっぱりこうした方がいい』と変わった。その変更、どこに記録した？」

【DJ町娘】「あっ...チャットにそのまま続きで書いちゃうかも」

【AI侍】「それでは、後から見た者は**最新の正がどれか分からぬ**。チャットログをすべて追わねば真実にたどり着けぬ。これが『死んだ仕様』である」

---

### 🗡️ AI侍の秘伝書

仕様を「生きた状態」で維持する3つの極意を授ける。

#### 秘伝その1：仕様の「正」を一箇所に定めよ

チャットログ、Wiki、README、Issue、コメント...仕様が散在すると、どれが正か分からなくなる。

- ✅ **ビジネスルールはDOMAIN.mdに**
- ✅ **技術的制約はARCHITECTURE.mdに**
- ✅ **実装パターンはPATTERNS.mdに**

「正」が一箇所にあれば、そこを更新するだけで全体が最新になる。

#### 秘伝その2：変更は「影響度」で扱え

仕様変更には3つのレベルがある。

- **Level 1（局所的）**：1ファイルの修正で済む
  - 例：バリデーションルールの微調整
  - 対応：該当ファイルのみ更新
- **Level 2（波及的）**：複数ファイルに影響
  - 例：APIレスポンス形式の変更
  - 対応：影響範囲を特定して文書更新
- **Level 3（構造的）**：アーキテクチャに影響
  - 例：認証方式の変更
  - 対応：ADRを書いて判断を記録

変更を「大きい/小さい」ではなく、「影響度」で分類せよ。

#### 秘伝その3：連鎖を維持せよ

仕様は孤立してはならぬ。設計、テスト、運用と連鎖していなければ、実装と乖離する。

```
仕様（DOMAIN.md）
  ↓
設計（ARCHITECTURE.md）
  ↓
テスト（TESTING.md）
  ↓
運用（DEPLOYMENT.md）
```

この連鎖が途切れている箇所を見つけたら、即座に補完せよ。

---

### 🎧 DJ町娘のまとめ

【DJ町娘】「なるほど！つまり、**『生きた仕様』とは、変更に追従し続ける仕様**なんですね。チャットログに散在させず、一箇所に集めて、変更のたびに更新する——これが『生きている』状態✨」

【AI侍】「見事なまとめである。次章では、この『生きた仕様』を7つの文書で実現する方法を学ぶ。これが本書の核心だ」

【DJ町娘】「ついに7文書の詳細ですね！楽しみです🎧」

---
