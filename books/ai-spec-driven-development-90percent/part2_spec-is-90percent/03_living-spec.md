# 第3章　仕様を"生きた成果物"にする

## この章で学ぶこと

- 静的ドキュメントから「生きた仕様」への転換
- 変更を「差分」ではなく「影響度」で扱う発想
- 仕様→設計→テスト→運用の連鎖を維持する方法

---

## 仕様＝合意の置き場所

### チャットログは仕様ではない

「あのとき Slack で決めたよね」
「PRのコメントに書いてあったはず」
「ミーティングで合意したじゃん」

これらは**仕様ではありません**。

なぜか？

1. **検索できない**：埋もれる、見つからない、探す時間がかかる
2. **変更履歴が追えない**：いつ、誰が、何を変えたかわからない
3. **AIが参照できない**：コンテキストとして渡せない

仕様とは、**参照可能な場所に置かれた、合意の記録**です。

### 仕様の条件

「これが仕様である」と言えるためには、以下の条件を満たす必要があります。

| 条件 | 説明 | 反例 |
|------|------|------|
| 参照可能 | いつでも誰でも見られる | Slackの過去ログ、会議の口頭合意 |
| バージョン管理 | 変更履歴が追える | 上書きされるWikiページ |
| 単一の真実 | 重複がない、矛盾がない | 複数のドキュメントに散在 |
| 機械可読 | AIやツールが読み取れる | スキャンされたPDF、画像 |

この条件を満たす最もシンプルな形式が、**GitリポジトリにあるMarkdownファイル**です。

### なぜMarkdownか

- **バージョン管理**：Gitで変更履歴が完璧に追える
- **差分表示**：PRで変更点がレビューできる
- **構造化**：見出し、リスト、テーブルで情報を整理
- **AI親和性**：LLMが最も扱いやすいテキスト形式
- **ツール連携**：静的サイト生成、Lintチェックが可能

---

## 変更は「差分」ではなく「影響度」で扱う

### 差分思考の限界

従来の仕様変更管理は「差分」に注目します。

```
変更前：パスワードは8文字以上
変更後：パスワードは12文字以上

差分：文字数が8→12に変更
```

しかし、この「差分」だけ見ても、**影響の大きさはわかりません**。

### 影響度思考への転換

「何が変わったか」ではなく、「何に影響するか」を考えます。

```markdown
## 変更：パスワード最小文字数 8 → 12

### 影響度：HIGH

### 影響範囲
- [ ] フロントエンド：バリデーションメッセージ更新
- [ ] バックエンド：バリデーションロジック更新
- [ ] テスト：パスワードバリデーションのテストケース追加
- [ ] ドキュメント：API仕様書のパラメータ説明更新
- [ ] 既存ユーザー：パスワード変更時の新ルール適用（ログイン時は旧パスワード許容？）

### 確認事項
- [ ] 移行期間は設けるか？
- [ ] 既存ユーザーへの通知は必要か？
- [ ] 監査ログへの記録方法は？
```

これが **影響度評価（changeImpact）** の発想です。

### 影響度の3段階

変更を以下の3段階で分類します。

| 影響度 | 定義 | 例 | 対応 |
|--------|------|-----|------|
| LOW | 文言・スタイルの修正 | エラーメッセージの文言変更、コメント修正 | 単独で対応可能 |
| MEDIUM | 既存概念の拡張 | フィールドの追加、オプション機能の追加 | 関連文書の確認が必要 |
| HIGH | 概念の再定義・削除 | データモデルの変更、APIの破壊的変更 | 全関連文書のレビューが必要 |

HIGH変更のときは、**必ず立ち止まって**影響範囲を洗い出します。

---

## "仕様→設計→テスト→運用"の連鎖を切らない

### 連鎖が切れるとき

多くのプロジェクトで、こんな状況が起きています。

```
仕様：「ユーザーは商品を購入できる」
  ↓（連鎖）
設計：CartServiceで購入処理
  ↓（連鎖が切れる）
テスト：???（何をテストすべきかわからない）
  ↓（連鎖が切れる）
運用：???（何を監視すべきかわからない）
```

仕様が曖昧なまま設計に入り、設計が曖昧なままテストを書き、テストが曖昧なまま本番に出す。

この**連鎖の切断**が、品質問題の根本原因です。

### 連鎖を維持する方法

連鎖を維持するには、**各フェーズの成果物が次のフェーズの入力になる**ように設計します。

```
仕様（PROJECT.md / DOMAIN.md）
  ↓ 何を作るか、ビジネスルールは何か
設計（ARCHITECTURE.md）
  ↓ どう作るか、コンポーネント構成は
テスト（TESTING.md）
  ↓ 何が正しいか、どう検証するか
運用（DEPLOYMENT.md）
  ↓ どう監視するか、障害時にどう対応するか
```

### 具体例：購入機能の連鎖

**仕様（DOMAIN.md）**

```markdown
## 購入ルール

- ユーザーは在庫がある商品のみ購入できる
- 購入数量は1〜10個まで
- 購入時に在庫を減算する（楽観的ロック使用）
- 在庫不足時は購入を拒否する
```

**設計（ARCHITECTURE.md）**

```markdown
## 購入処理フロー

1. CartServiceが購入リクエストを受け取る
2. InventoryServiceで在庫確認（楽観的ロック取得）
3. OrderServiceで注文作成
4. InventoryServiceで在庫減算（ロック解放）
5. PaymentServiceで決済処理
6. NotificationServiceで確認メール送信

### 障害パターン
- 在庫確認後〜減算前に他ユーザーが購入：409 Conflict返却
- 決済失敗：在庫をロールバック
```

**テスト（TESTING.md）**

```markdown
## 購入機能のテストケース

### 正常系
- [ ] 在庫がある商品を1個購入できる
- [ ] 在庫がある商品を10個購入できる

### 異常系
- [ ] 在庫0の商品は購入できない（409）
- [ ] 11個以上の購入はバリデーションエラー（400）
- [ ] 購入途中で他ユーザーに在庫を取られた場合（409）

### 負荷テスト
- [ ] 同時100ユーザーの購入で在庫の整合性が保たれる
```

**運用（DEPLOYMENT.md）**

```markdown
## 購入機能の監視

### メトリクス
- purchase_success_rate: 購入成功率（目標: 99.9%）
- inventory_conflict_rate: 在庫競合率（警告: 5%超過）

### アラート
- 購入成功率が95%を下回ったら即座に通知
- 在庫競合率が10%を超えたら在庫データ確認

### 障害対応Runbook
- [購入失敗急増時の対応手順](./runbooks/purchase-failure.md)
```

この**連鎖が維持されている**から、AIは一貫した実装ができます。

---

## 章末チェックリスト

- [ ] 仕様がチャットログやWikiに散在していないか確認する
- [ ] 最近の仕様変更を「影響度」で分類してみる
- [ ] 仕様→設計→テスト→運用の連鎖が途切れている箇所を特定する
- [ ] 途切れている箇所を補完するドキュメントを作成する計画を立てる

---

## 次章への橋渡し

この章では、仕様を「生きた成果物」として維持する考え方を学びました。

次章では、この考え方を具体化した**7文書構成**を紹介します。どの情報をどの文書に置くか、7つの文書がどのように連携するか、詳細に解説します。
