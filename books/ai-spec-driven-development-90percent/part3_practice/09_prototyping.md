# 第9章　プロトタイピング：仕様を書く前に"動くもの"で確かめる

## この章で学ぶこと

- PoCと本実装の違い——何を検証し、何を捨てるか
- AIで素早くプロトタイプを作るアプローチ
- PoCから仕様に落とすタイミングと方法
- 失敗したPoCの正しい扱い方

---

## なぜ「仕様の前」にプロトタイプが必要か

第2部では「仕様が9割」と繰り返しました。それなのに「仕様を書く前にプロトタイプを作れ」とは矛盾しているように聞こえるかもしれません。

しかし、現実には**仕様を書こうにも書けない**場面があります。

- **技術的な実現可能性が不明**——「この外部APIは本当にリアルタイムで返してくれるのか？」
- **ユーザー体験が想像できない**——「この画面遷移で本当に分かりやすいのか？」
- **ビジネス仮説が未検証**——「この機能、そもそもユーザーが欲しがるのか？」

こうした不確実性が高い状態で詳細な仕様を書くと、**書き直しのコストが膨大になります**。仕様書は関係者間の合意文書なので、変更にはレビューと承認が必要です。まだ方向性すら固まっていない段階で合意プロセスを回すのは非効率です。

そこで、**プロトタイプ（PoC）で不確実性を潰してから仕様を書く**という順序が効きます。

```text
従来の流れ：仕様（不確実）→ 実装 → 「違った」→ 仕様修正 → 再実装
推奨の流れ：PoC（検証）→ 仕様（確実）→ 本実装
```

### PoCと本実装の違い

PoCと本実装は目的が根本的に異なります。この違いを意識しないと、PoCがそのまま本番コードに化けるという事故が起きます。

| 観点 | PoC（プロトタイプ） | 本実装 |
|------|---------------------|--------|
| **目的** | 仮説の検証・学習 | 価値の提供 |
| **寿命** | 数日〜数週間 | 数年 |
| **品質基準** | 動けばよい | テスト・セキュリティ・保守性 |
| **コードの行き先** | 捨てる前提 | リポジトリに残る |
| **仕様書** | 不要（検証項目リストで十分） | 必須（7文書） |
| **レビュー** | 結果の共有のみ | コードレビュー必須 |

**鉄則：PoCのコードは本実装に持ち込まない。**

PoCで得るのは「知見」であって「コード」ではありません。PoCで分かったことを仕様に落とし、仕様に基づいてゼロから本実装するのが正しい流れです。

---

## AIで素早くPoCを作る

AIコーディングツールは、PoCとの相性が抜群です。理由は明確で、PoCに求められる品質水準が低いからです。

本実装では「テストカバレッジ」「エラーハンドリング」「セキュリティ」など多くの制約をAIに伝える必要があります。一方、PoCでは「とにかく動くもの」が目的なので、雑な指示でも十分に機能します。

### ステップ1：検証項目を明確にする

PoCを始める前に、**何を検証するか**を1〜3個に絞ります。

```markdown
## PoC検証項目

### 検証したいこと
1. Stripe Webhookのイベント受信〜DB更新が1秒以内に完了するか

### 検証しないこと（本実装で対応）
- エラーハンドリング
- 認証・認可
- UIデザイン
- テスト
```

検証項目が4個以上になったら、PoCを分割してください。1つのPoCで多くを検証しようとすると、どの結果が何に起因するか分からなくなります。

### ステップ2：AIに「捨てるコード」であることを伝える

AIに指示を出すとき、**PoCであることを明示する**のがポイントです。明示しないと、AIは親切心からテストやエラーハンドリングを追加し、必要以上に時間がかかります。

```markdown
## 指示の例

これはPoCです。以下の方針で実装してください：
- テスト不要
- エラーハンドリングは最小限（console.logで十分）
- 型定義は any でもOK
- コメント不要
- 1ファイルに収めてよい

### 検証したいこと
Stripe Webhookを受信し、イベント種別に応じて
PostgreSQLのsubscriptionsテーブルを更新する。
レスポンスタイムを計測したい。
```

この指示なら、AIは余計な作業をせず検証対象に集中してくれます。

### ステップ3：隔離された環境で実行する

PoCのコードは**本番リポジトリに混ぜない**のが鉄則です。

```bash
# 方法1：別ディレクトリで作る
mkdir -p poc/stripe-webhook-latency
cd poc/stripe-webhook-latency

# 方法2：本番リポジトリ内の場合は.gitignoreで除外
echo "poc/" >> .gitignore
```

PoCが本番リポジトリに入ると、「とりあえず動いてるし、このまま使おう」という誘惑に負けます。物理的に分離することで、PoCを捨てる判断がしやすくなります。

### ステップ4：検証結果を記録する

PoCの実行結果は、**コードではなく知見として記録**します。以下はStripe Webhookの検証を例にした記録テンプレートです。

```markdown
## PoC結果：Stripe Webhook レイテンシ検証

### 検証日
2026-01-20

### 結果
- Webhook受信〜DB更新：平均 320ms（目標1秒以内 → ✅ 達成）
- ピーク時（100イベント/秒）：平均 780ms（✅ 達成）
- 1000イベント/秒では 2.1秒に悪化（⚠️ 要対策）

### 発見した制約
- PostgreSQLの接続プール上限（デフォルト20）がボトルネック
- Stripeのリトライ間隔は最短1時間なのでバッファに余裕あり

### 本実装への申し送り
- 接続プールは50以上を推奨（ARCHITECTURE.mdに記載予定）
- イベントのべき等性チェックは必須（DOMAIN.mdに記載予定）
- レート制限は当面不要（1000イベント/秒は現実的でない）
```

この記録が、次のステップで仕様に落とすときのインプットになります。

---

## PoCから仕様に落とす

PoCで検証が完了したら、知見を7文書に反映します。ここが「仕様駆動開発」との接続点です。

### どのタイミングで仕様化するか

PoCから仕様に切り替えるタイミングの判断基準は3つです。

1. **技術的な実現可能性が確認できた**——「できる」と分かった
2. **非機能要件の目安が立った**——「どのくらいの性能か」が分かった
3. **ビジネス判断ができた**——「この方向で進める」とステークホルダーが同意した

3つすべてが揃う必要はありません。1つでも確認できれば、その部分から仕様化を始められます。

### PoCの知見を7文書に落とす

PoCで得た知見は、以下のように7文書に分配します（代表的な5文書への分配例）。

| PoCの知見 | 反映先の文書 | 記載内容 |
|-----------|-------------|---------|
| 技術的制約 | ARCHITECTURE.md | 接続プール設定、インフラ要件 |
| ビジネスルール | DOMAIN.md | べき等性チェック、状態遷移 |
| 実装パターン | PATTERNS.md | Webhook処理のコードパターン |
| テスト観点 | TESTING.md | 負荷テストのシナリオ、閾値 |
| 運用要件 | DEPLOYMENT.md | 監視項目、アラート閾値 |

**重要：PoCのコードをコピペしないこと。** コードではなく「PoCで分かったこと」を仕様として記述し、本実装はその仕様に基づいてAIに指示します。

### 仕様化のテンプレート

PoCの結果を仕様に変換する際の流れです。

```markdown
## ARCHITECTURE.md に追記する例

### Stripe Webhook 処理基盤

#### 背景（PoCで検証済み）
PoC（2026-01-20実施）により、以下を確認：
- 平均レイテンシ 320ms（SLO 1秒以内を満たす）
- 接続プール20ではピーク時にボトルネック発生

#### 技術的決定
- PostgreSQL接続プール上限：50
- Webhookハンドラはべき等性を保証する
- リトライはStripe側の仕組みに委ねる（カスタム実装不要）
```

---

## 失敗したPoCの扱い方

PoCが「失敗」したとき（検証項目が達成できなかったとき）、それは**貴重な情報**です。

### 「失敗」は仕様を守った証拠

PoCの失敗は、**やってはいけないことが分かった**という成功です。仕様化のプロセスでは、「やらないこと」を決めるのも重要な意思決定です。

```markdown
## PoC結果：WebSocket常時接続 → ❌ 不採用

### 検証結果
- 1000接続でメモリ使用量 2.4GB（目標1GB以下 → ❌）
- 接続維持のためのPing/Pongオーバーヘッドが想定以上

### 決定
WebSocket常時接続は不採用。代替としてSSE（Server-Sent Events）を検討。

### ARCHITECTURE.md への記載
> **ADR-007: リアルタイム通信方式**
> - 決定：SSEを採用（WebSocketは不採用）
> - 理由：WebSocketはメモリ効率でSLOを満たせない（PoC検証済み）
> - 代替案のPoC：SSEで同等の検証を実施予定
```

### 失敗PoCの記録を残す

失敗したPoCの記録は、**ADR（Architecture Decision Record）として残す**のが効果的です。将来、別のメンバーが「WebSocketにしたらどうか」と提案したとき、過去の検証結果を示せます。

---

## 章末チェックリスト

- [ ] PoCの検証項目を1〜3個に絞ったか
- [ ] AIへの指示に「PoCである」ことを明示したか
- [ ] PoCのコードを本番リポジトリから隔離したか
- [ ] 検証結果を「コード」ではなく「知見」として記録したか
- [ ] 知見を適切な仕様文書（7文書）に反映したか
- [ ] 失敗したPoCもADRとして記録したか
- [ ] PoCのコードを本実装にコピペしていないか
