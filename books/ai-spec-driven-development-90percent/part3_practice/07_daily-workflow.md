# 第7章　日々の開発フロー：AIに"タスク"を渡す前にやること

## この章で学ぶこと

- Issueベースのスコープ絞り込み
- AIに渡す前の3つの確認ポイント
- 70%完成度でのPR運用の具体的な流れ

---

## Issueベースの開発フロー全体像

### フローの概要

```
1. Issueを作成（スコープを絞る）
   ↓
2. 3つの確認（仕様・設計・テスト）
   ↓
3. AIにタスクを渡す
   ↓
4. 70%完成度でPRを作成
   ↓
5. レビュー→修正→マージ
   ↓
6. 指摘をナレッジ化
```

このフローを回すことで、AIの出力品質は継続的に向上します。

---

## ステップ1：Issueを作成する

### なぜIssueから始めるのか

「ログイン機能を作って」とAIに直接指示するのではなく、**まずIssueを作る**。

これには3つの理由があります。

1. **スコープが明確になる**：何を作る/作らないが記録される
2. **追跡可能になる**：後から「なぜこう実装したか」がわかる
3. **AIへの入力になる**：Issueそのものがコンテキストになる

### 良いIssueの構造

```markdown
## Issue #42: [機能名の動詞形]

### 背景
[なぜこの機能が必要か、1〜2文で]

### 受け入れ基準
- [ ] [具体的な動作1]
- [ ] [具体的な動作2]
- [ ] [具体的な動作3]

### 技術的制約
- [使用すべきライブラリ/パターン]
- [既存コードとの接続点]
- [パフォーマンス要件]

### スコープ外
- [明示的に今回やらないこと]

### 関連文書
- [ARCHITECTURE.md#認証](../docs/ARCHITECTURE.md#認証)
- [DOMAIN.md#ユーザー](../docs/DOMAIN.md#ユーザー)
```

### 具体例：ログイン機能

```markdown
## Issue #42: ログインAPIエンドポイントの実装

### 背景
ユーザーがメールアドレスとパスワードでログインできるようにする。
セキュリティ要件としてブルートフォース対策を含む。

### 受け入れ基準
- [ ] POST /api/v1/auth/login でログインできる
- [ ] 成功時はJWTトークン（アクセス/リフレッシュ）を返す
- [ ] パスワード誤り5回でアカウントを15分ロック
- [ ] ログイン試行を監査ログに記録

### 技術的制約
- JWT署名はRS256（既存の鍵ペアを使用）
- リフレッシュトークンはRedisに保存
- パスワード検証はArgon2id
- レート制限はRedisのスライディングウィンドウ

### スコープ外
- パスワードリセット（Issue #43）
- OAuth/ソーシャルログイン（Issue #44）
- MFA（Issue #45）

### 関連文書
- [ARCHITECTURE.md#認証フロー](../docs/ARCHITECTURE.md#認証フロー)
- [DOMAIN.md#認証ルール](../docs/DOMAIN.md#認証ルール)
```

---

## ステップ2：3つの確認ポイント

Issueを作成したら、AIに渡す前に**3つの確認**を行います。

### 確認1：仕様の粒度

**受け入れ基準が具体的に書けているか？**

```markdown
❌ 曖昧な受け入れ基準
- [ ] ログインできる
- [ ] エラーハンドリングする

✅ 具体的な受け入れ基準
- [ ] POST /api/v1/auth/login でログインできる
- [ ] メール/パスワードが正しければ200とトークンを返す
- [ ] メールが存在しなければ401とエラーメッセージを返す
- [ ] パスワードが間違っていれば401とエラーメッセージを返す
```

確認の問い：**「これを読んだ人が、テストケースを書けるか？」**

### 確認2：設計の粒度

**アーキテクチャ制約が明示されているか？**

```markdown
❌ 制約が不明確
- 認証を実装する

✅ 制約が明確
- JWT署名はRS256
- 既存のauthServiceを拡張
- エラーレスポンスはsrc/errors/auth.tsの形式
```

確認の問い：**「どこに・どう実装すべきか、迷う余地がないか？」**

### 確認3：テストの粒度

**テストが仕様を「代替」していないか？**

これは重要なポイントです。

```markdown
❌ テストが仕様の代替になっている
「テストコード見ればわかるでしょ」
→ テストを読まないと要件がわからない

✅ 仕様が先、テストは検証
1. 仕様（Issue）：「パスワード誤り5回でロック」
2. テスト：その仕様をコードで検証
```

確認の問い：**「仕様を読まずにテストだけ見て、正しさを判断できるか？」**

→ できてしまうなら、仕様が足りない。

---

## ステップ3：AIにタスクを渡す

### プロンプトの構造

```markdown
## タスク
Issue #42 を実装してください。

## コンテキスト
- Issue: [IssueのURL or 内容をコピー]
- 関連文書:
  - docs/ARCHITECTURE.md
  - docs/DOMAIN.md
  - docs/PATTERNS.md

## 制約
- 既存の認証サービス（src/services/auth/）を拡張する形で実装
- 新規ファイルは src/services/auth/login.ts に作成
- テストは src/services/auth/__tests__/login.test.ts に作成

## 出力
1. 実装コード
2. テストコード
3. 影響を受ける既存ファイルの変更点
```

### Claude Codeを使う場合

Claude Codeでは、Issueの内容をそのまま渡せます。

```bash
# GitHubのIssueを直接参照
claude "Issue #42 を実装して。docs/配下の仕様に従って。"
```

7文書がリポジトリにあれば、Claude Codeは自動的に参照します。

---

## ステップ4：70%完成度でPRを作成

### 完璧を求めない

AIが生成したコードを見て、「ここが微妙だな」と思うことがあるでしょう。

**そこで止まらないでください。**

70%の完成度でPRを出す理由：

1. **レビューで具体的な指摘を得られる**
2. **指摘内容がAIへの次の入力になる**
3. **完璧を目指す時間より、反復の方が速い**

### PRの書き方

```markdown
## PR #42: ログインAPIエンドポイントの実装

### 概要
Issue #42 の実装です。

### 変更内容
- `src/services/auth/login.ts`: ログインサービスを追加
- `src/api/routes/auth.ts`: ログインエンドポイントを追加
- `src/services/auth/__tests__/login.test.ts`: テストを追加

### 確認ポイント
- [ ] JWT署名がRS256になっているか
- [ ] ブルートフォース対策が正しく動作するか
- [ ] エラーレスポンスの形式が統一されているか

### 今後の対応（レビュー後）
- エッジケースの追加テスト
- パフォーマンス最適化（必要に応じて）

### 関連
- Closes #42
```

---

## ステップ5：レビュー→修正→マージ

### レビュー指摘をAIに渡す

レビューコメントは、**AIへの次の入力として最適**です。

```markdown
## レビュー指摘
「validateCredentials関数、バリデーションとDB問い合わせが混ざってる。分離して。」

## AIへの指示
上記のレビュー指摘に対応してください。
validateCredentials関数を以下のように分割してください：
1. validateLoginInput: 入力値のバリデーション
2. findUserByEmail: ユーザー検索
3. verifyPassword: パスワード検証

それぞれ単一責任になるよう実装してください。
```

レビュー指摘には**具体的な問題と期待される解決方向**が含まれているため、AIは的確に修正できます。

### 反復の効果

```
1回目のPR → レビュー指摘5件
  ↓ AIで修正
2回目 → レビュー指摘2件
  ↓ AIで修正
3回目 → LGTM
```

反復するたびに、**スコープがさらに狭まる**ため、AIの出力精度は上がります。

---

## ステップ6：指摘をナレッジ化

### 繰り返される指摘を記録する

レビューで同じ指摘が何度も出る場合、それは**PATTERNS.mdに蓄積すべき知識**です。

```markdown
## よくある指摘と対応

### 関数の責務分離
❌ 1つの関数で複数のことをする
✅ 単一責任の関数に分割する

例：
- validateAndSave → validate + save
- fetchAndTransform → fetch + transform

### エラーレスポンスの統一
❌ throw new Error('message')
✅ return err(new SpecificError(details))

### テストの粒度
❌ 1つのテストで複数のケースをテスト
✅ 1テスト1ケース（Arrange-Act-Assert）
```

### 自動チェックへの昇格

何度も指摘されるパターンは、**自動チェックに組み込む**ことを検討します。

- ESLintカスタムルール
- pre-commitフック
- サブエージェントによるレビュー

これにより、「指摘される前に防ぐ」サイクルが回り始めます。

---

## 章末チェックリスト

- [ ] 次のタスクをIssueとして作成する
- [ ] Issueに「受け入れ基準」「技術的制約」「スコープ外」を含める
- [ ] AIに渡す前に3つの確認（仕様・設計・テスト）を行う
- [ ] 70%完成度でPRを出す心構えを持つ
- [ ] レビュー指摘はAIへの入力として活用する
- [ ] 繰り返される指摘はPATTERNS.mdに記録する

---

## 次章への橋渡し

この章では、日々の開発フローを学びました。

次章では、**文書追加の意思決定**——「この情報はどの文書に置くべきか」という判断基準を解説します。
