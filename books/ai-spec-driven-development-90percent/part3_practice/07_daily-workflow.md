# 第7章　日々の開発フロー：AIに"タスク"を渡す前にやること

## この章で学ぶこと

- Issueベースのスコープ絞り込み
- **Issue = AIへのコンテキスト選択** という考え方
- AIに渡す前の3つの確認ポイント
- 70%完成度でのPR運用の具体的な流れ

---

## なぜIssueベースの開発が重要なのか

AI仕様駆動開発では、**Issueを起点にすべてが始まります**。これは単なるタスク管理ではなく、AIとの協働を最適化するための設計です。

### スコープの明確化

Issueに記載することで、作業範囲が自然と小さくなります。「ログイン機能を作る」という曖昧な指示ではなく、「パスワードリセット機能のメール送信部分を実装する」という具体的なスコープに落とし込めます。AIは限定されたスコープの方が精度高く作業できます。

### コンテキストの集約

Issueには、参照すべきドキュメント、関連するコード、受け入れ基準がすべて記載されています。AIはIssueを読むだけで「何を作るか」「どの仕様に従うか」「どうなれば完成か」を把握できます。

### マージ可否の判断基準

Issueに書かれた受け入れ基準は、そのままマージの条件になります。AIはこの基準を見て「この実装で受け入れ基準を満たしているか」を自己判断できます。レビュー時も、レビュアーは受け入れ基準に照らして確認するだけで済みます。

### 履歴の追跡性

AIは、Issue・ブランチ・PRの連携を追跡できます。「以前のIssue #42で何を決めたか」「関連するPR #58でどんな実装をしたか」を参照することで、プロジェクトの文脈を理解した上で作業できます。過去の意思決定を踏まえた一貫性のある実装が可能になります。

---

## Issueベースの開発フロー全体像

![AI開発フロー](../images/ch07-daily-workflow.jpeg)

### フローの概要

```text
1. Issueを作成（スコープを絞る）
   ↓
2. 3つの確認（仕様・設計・テスト）
   ↓
3. AIにタスクを渡す
   ↓
4. 70%完成度でPRを作成
   ↓
5. レビュー→修正→マージ
   ↓
6. 指摘をナレッジ化
```

このフローを回すことで、AIの出力品質は継続的に向上します。

---

## ステップ1：Issueを作成する

### なぜIssueから始めるのか

「ログイン機能を作って」とAIに直接指示するのではなく、**まずIssueを作る**。

これには3つの理由があります。

1. **スコープが明確になる**：何を作る/作らないが記録される
2. **追跡可能になる**：後から「なぜこう実装したか」がわかる
3. **AIへの入力になる**：Issueそのものがコンテキストになる

### 良いIssueの構造

```markdown
## Issue #42: [機能名の動詞形]

### 背景
[なぜこの機能が必要か、1〜2文で]

### 受け入れ基準
- [ ] [具体的な動作1]
- [ ] [具体的な動作2]
- [ ] [具体的な動作3]

### 技術的制約
- [使用すべきライブラリ/パターン]
- [既存コードとの接続点]
- [パフォーマンス要件]

### スコープ外
- [明示的に今回やらないこと]

### 関連文書
- [ARCHITECTURE.md#認証](../docs/ARCHITECTURE.md#認証)
- [DOMAIN.md#ユーザー](../docs/DOMAIN.md#ユーザー)
```

### 具体例：ログイン機能

```markdown
## Issue #42: ログインAPIエンドポイントの実装

### 背景
ユーザーがメールアドレスとパスワードでログインできるようにする。
セキュリティ要件としてブルートフォース対策を含む。

### 受け入れ基準
- [ ] POST /api/v1/auth/login でログインできる
- [ ] 成功時はJWTトークン（アクセス/リフレッシュ）を返す
- [ ] パスワード誤り5回でアカウントを15分ロック
- [ ] ログイン試行を監査ログに記録

### 技術的制約
- JWT署名はRS256（既存の鍵ペアを使用）
- リフレッシュトークンはRedisに保存
- パスワード検証はArgon2id
- レート制限はRedisのスライディングウィンドウ

### スコープ外
- パスワードリセット（Issue #43）
- OAuth/ソーシャルログイン（Issue #44）
- MFA（Issue #45）

### 関連文書
- [ARCHITECTURE.md#認証フロー](../docs/ARCHITECTURE.md#認証フロー)
- [DOMAIN.md#認証ルール](../docs/DOMAIN.md#認証ルール)
```

### 悪いIssueの例と改善

良いIssueの例を見ましたが、「悪いIssue」を知ることも重要です。実際にAIの出力が乱れた例を紹介します。

#### 受け入れ基準が曖昧なIssue

```markdown
## Issue #99: ユーザー管理機能の改善

### 背景
ユーザー管理画面が使いにくいので改善したい。

### 受け入れ基準
- [ ] UIを改善する
- [ ] パフォーマンスを向上させる
- [ ] エラーハンドリングを追加する
```

このIssueでは、AIは「UIを改善する」の意味を推測するしかありません。結果、デザイナーの意図とは違うレイアウト変更をしたり、不要な機能を追加したりします。「テーブルのソート機能を追加する」「ローディング表示を0.5秒以内にする」のように、**検証可能な基準** を書く必要があります。

#### 技術的制約が欠落したIssue

```markdown
## Issue #100: メール送信機能を追加

### 受け入れ基準
- [ ] ユーザー登録時にメールを送信する
```

技術的制約がないため、AIは自由にメール送信ライブラリを選びます。プロジェクトで使っているSendGridではなく、別のサービスを使った実装が出てくるかもしれません。また、既存のメール送信基盤があることを知らずに、一から実装することもあります。

#### スコープ外が不明確なIssue

```markdown
## Issue #101: 検索機能を実装

### 受け入れ基準
- [ ] 商品を検索できる
```

スコープ外が書かれていないと、AIは「全文検索も必要？」「ファセット検索は？」「オートコンプリートは？」と拡大解釈しがちです。本来はシンプルなキーワード検索だけでよかったのに、Elasticsearchを使った本格的な検索基盤を提案されることがあります。

---

## Issue テンプレートでスコープ管理を仕組み化する

ここまで「良いIssue」の書き方を見てきましたが、現実には毎回ゼロから書くと品質がばらつきます。人によって書き方が違ったり、忙しいときにスコープ外を省略してしまったりします。

**解決策は、GitHub Issue テンプレートを使って「型」を強制すること** です。

### GitHub Issue テンプレート機能

GitHubには、リポジトリの `.github/ISSUE_TEMPLATE/` ディレクトリにMarkdownファイルを配置するだけで、Issue作成時にテンプレート選択画面が表示される機能があります。

```text
.github/
└── ISSUE_TEMPLATE/
    ├── feature.md        # 新機能追加
    ├── bug.md            # バグ修正
    ├── refactor.md       # リファクタリング
    ├── infra.md          # インフラ変更
    └── docs.md           # ドキュメント更新
```

各ファイルの先頭にYAML frontmatterを記述すると、テンプレート名・ラベル・タイトルプレフィックスが自動設定されます。

```yaml
---
name: 新機能追加
about: 新しい機能を追加する
title: 'feat: '
labels: enhancement
---
```

Issue作成画面で「New Issue」をクリックすると、テンプレートの一覧が表示され、タスク種別に合ったフォーマットで書き始められます。

### テンプレート例1：新機能追加

新機能追加テンプレートの最大のポイントは、**「参照ドキュメント」セクション** です。前述の「タスク種別ごとの推奨参照文書」の表が、テンプレートにそのまま組み込まれています。

```markdown
---
name: 新機能追加
about: 新しい機能を追加する
title: 'feat: '
labels: enhancement
---

## 概要

[この機能が何を実現するか、1〜2文で説明]

## 背景

[なぜこの機能が必要か、ビジネス上の理由]

## 参照ドキュメント（AIへ：必ず読んでください）

> **必須参照**: MASTER, ARCHITECTURE, DOMAIN

- [ ] MASTER.md
- [ ] ARCHITECTURE.md#該当セクション
- [ ] DOMAIN.md#該当セクション

> **推奨参照**: PATTERNS, TESTING

- [ ] PATTERNS.md
- [ ] TESTING.md

## 受け入れ基準

- [ ] [具体的な動作1]
- [ ] [具体的な動作2]
- [ ] [具体的な動作3]

## 技術的制約

- [使用すべきライブラリ/パターン]
- [既存コードとの接続点]
- [パフォーマンス要件]

## スコープ外（今回は対象外）

> **通常不要**: DEPLOYMENT

- DEPLOYMENT.md（インフラ変更なし）
- [その他、今回やらないこと]
```

注目してほしいのは、**「参照ドキュメント（AIへ：必ず読んでください）」というセクション名** です。AIがこのIssueを読んだとき、どのドキュメントを優先的に参照すべきかが一目瞭然です。テンプレートそのものが「AIへの指示書」として機能しています。

### テンプレート例2：バグ修正

バグ修正テンプレートでは、**再現手順と環境情報** がスコープの絞り込みに効きます。

```markdown
---
name: バグ修正
about: バグを報告・修正する
title: 'fix: '
labels: bug
---

## 概要

[バグの概要を1〜2文で説明]

## 再現手順

1. [手順1]
2. [手順2]
3. [手順3]

## 期待される動作

[本来どう動作すべきか]

## 実際の動作

[現在どう動作しているか]

## 参照ドキュメント（AIへ：必ず読んでください）

> **必須参照**: 関連Issue, PATTERNS

- [ ] #XX [関連する過去のIssue]
- [ ] PATTERNS.md#エラーハンドリング

## スコープ外（今回は参照不要）

> **通常不要**: DOMAIN全体（バグ修正のため仕様変更なし）

- DOMAIN.md（仕様変更なし）
- PROJECT.md（ビジネス要件に変更なし）

## 環境

- OS: [例: macOS 14.0]
- Node.js: [例: 20.x]

## エラーログ

\```
[エラーメッセージがあれば貼り付け]
\```
```

再現手順を書くことで「何が壊れているか」が限定され、AIは修正範囲を正確に特定できます。新機能テンプレートと比べて必須参照が少ない点にも注目してください。バグ修正ではDOMAIN全体を読む必要はなく、関連IssueとPATTERNSだけで十分です。

### テンプレート例3：リファクタリング

リファクタリングテンプレートの特徴は、**Before/After形式** です。

```markdown
---
name: リファクタリング
about: コードの改善・リファクタリング
title: 'refactor: '
labels: refactor
---

## 概要

[リファクタリングの目的を1〜2文で説明]

## 参照ドキュメント（AIへ：必ず読んでください）

> **必須参照**: ARCHITECTURE, PATTERNS

- [ ] ARCHITECTURE.md
- [ ] PATTERNS.md

## 対象ファイル

- `src/path/to/file.ts`

## 変更方針

### Before

\```typescript
// 現在のコード（問題点をコメントで明示）
\```

### After

\```typescript
// 改善後のイメージ
\```

## 受け入れ基準

- [ ] 既存のテストがすべてパスする
- [ ] 新しいコードが PATTERNS.md に準拠している

## スコープ外（今回は参照不要）

> **通常不要**: DOMAIN（機能変更なし）

- DOMAIN.md（ビジネスロジックの変更なし）
```

Before/After形式で「何をどう変えるか」を明示することで、変更範囲がそのままスコープになります。リファクタリングでは機能追加や仕様変更は行わないため、DOMAINは参照不要と明記されています。

### テンプレートの設計思想

3つのテンプレートに共通する設計思想をまとめます。

**1. 「参照ドキュメント」セクションが全テンプレートにある**

前述の「タスク種別ごとの推奨参照文書」の表を思い出してください。新機能ならMASTER・ARCHITECTURE・DOMAINが必須、バグ修正なら関連IssueとPATTERNSが必須でした。この対応関係が、各テンプレートにそのまま埋め込まれています。テンプレートを選ぶだけで、適切な参照文書が自動的に提示されます。

**2. 「スコープ外」セクションが全テンプレートにある**

空欄のセクションが目に入ると、人は自然と記入したくなります。「スコープ外」が最初から用意されていることで、「今回やらないこと」を考える習慣がつきます。

**3. テンプレート自体がAIへの指示書になっている**

「AIへ：必ず読んでください」という文言は、人間のためではなくAIのためのものです。AIがIssueを読んだとき、どの情報を優先的に処理すべきかが明示されます。テンプレートは「人間が書くためのフォーマット」であると同時に、「AIが読むための構造化データ」でもあるのです。

---

## Issue = AIへのコンテキスト選択

### 全7文書を毎回読む必要はない

ここで重要な概念を紹介します。

**Issue作成とは、「AIに何を読ませるか」を選択する行為** です。

プロジェクトには7文書（MASTER、PROJECT、ARCHITECTURE、DOMAIN、PATTERNS、TESTING、DEPLOYMENT）があり、さらに開発が進むとADR、ナレッジ、詳細仕様など、文書は増えていきます。

しかし、**すべてのタスクで全文書を読む必要はありません**。

- ログイン機能の実装 → ARCHITECTURE（認証フロー）、DOMAIN（認証ルール）を読めばよい
- CSSの修正 → PATTERNSのスタイリング規約だけで十分
- デプロイ設定の変更 → DEPLOYMENTのみ

Issueの「関連文書」セクションは、**AIに「このタスクではこれだけ読めばよい」と指示する場所** なのです。

### タスク種別ごとの推奨参照文書

以下の表を参考に、タスク種別に応じた文書を選択してください。

| タスク種別 | 必須参照 | 推奨参照 | 通常不要 |
| --------- | ------- | ------- | ------- |
| 新機能追加 | MASTER, ARCHITECTURE, DOMAIN | PATTERNS, TESTING | DEPLOYMENT |
| バグ修正 | 関連Issue, PATTERNS | TESTING | DOMAIN全体 |
| リファクタリング | ARCHITECTURE, PATTERNS | TESTING | DOMAIN |
| インフラ変更 | MASTER, DEPLOYMENT | ARCHITECTURE | DOMAIN |
| ドキュメント更新 | MASTER | 対象文書 | その他 |

**ポイント**：

- 「必須参照」はIssueに必ずリンクを記載
- 「通常不要」は明示的に「スコープ外」に記載することで、AIの無駄な参照を防ぐ

### 関連Issueの参照

過去の類似Issueも重要なコンテキストです。

```markdown
### 関連Issue
- #123 ログイン機能の基本実装（参考：認証フローの詳細）
- #145 認証エラーハンドリング（参考：エラーレスポンス形式）
```

関連Issueを参照することで：

- **過去の設計判断** を引き継げる
- **同じ失敗** を繰り返さない
- **一貫した実装** が得られる

### スコープ外の明示

「読まなくてよい文書」を明示することも重要です。

```markdown
### スコープ外（今回は参照不要）
- DEPLOYMENT.md（インフラ変更なし）
- GLOSSARY.md（新用語の追加なし）
- PROJECT.md（ビジネス要件に変更なし）
```

これにより、AIは**必要なコンテキストだけに集中** できます。

### 「読まなくてよい」の判断基準

「スコープ外」に何を書くべきか、迷うことがあります。以下の判断基準を参考にしてください。

「このタスクの実装中に、その文書を参照する場面があるか？」を問いかけます。

- DEPLOYMENT.md：「このコードはどうデプロイされるか」を意識する必要があるか？→ 通常のバックエンド実装なら不要
- PROJECT.md：「なぜこの機能が必要か」を確認する必要があるか？→ 要件が明確なら不要
- DOMAIN.md：「このビジネスルールに従うべきか」を確認する必要があるか？→ 技術的なリファクタリングなら不要

逆に、「必要かもしれない」と思ったら**スコープ外に入れない**ことが重要です。AIが必要な情報を見つけられないほうが、余計な情報を読むよりも問題が大きいからです。

注意点として、過剰にコンテキストを絞りすぎると、AIが既存のパターンを無視した実装をすることがあります。迷ったら「PATTERNS.mdは常に参照」としておくと、一貫性のある実装が得られます。

---

## ステップ2：3つの確認ポイント

Issueを作成したら、AIに渡す前に**3つの確認** を行います。

### 確認1：仕様の粒度

**受け入れ基準が具体的に書けているか？**

```markdown
❌ 曖昧な受け入れ基準
- [ ] ログインできる
- [ ] エラーハンドリングする

✅ 具体的な受け入れ基準
- [ ] POST /api/v1/auth/login でログインできる
- [ ] メール/パスワードが正しければ200とトークンを返す
- [ ] メールが存在しなければ401とエラーメッセージを返す
- [ ] パスワードが間違っていれば401とエラーメッセージを返す
```

確認の問い：**「これを読んだ人が、テストケースを書けるか？」**

### 確認2：設計の粒度

**アーキテクチャ制約が明示されているか？**

```markdown
❌ 制約が不明確
- 認証を実装する

✅ 制約が明確
- JWT署名はRS256
- 既存のauthServiceを拡張
- エラーレスポンスはsrc/errors/auth.tsの形式
```

確認の問い：**「どこに・どう実装すべきか、迷う余地がないか？」**

### 確認3：テストの粒度

**テストが仕様を「代替」していないか？**

これは重要なポイントです。

```markdown
❌ テストが仕様の代替になっている
「テストコード見ればわかるでしょ」
→ テストを読まないと要件がわからない

✅ 仕様が先、テストは検証
1. 仕様（Issue）：「パスワード誤り5回でロック」
2. テスト：その仕様をコードで検証
```

確認の問い：**「仕様を読まずにテストだけ見て、正しさを判断できるか？」**

→ できてしまうなら、仕様が足りない。

#### 「仕様が先」を実践する難しさ

「仕様が先、テストは検証」という考え方は、TDD（テスト駆動開発）に慣れた人には違和感があるかもしれません。TDDでは「テストを先に書く」ことで要件を明確にするアプローチを取るからです。

しかし、AI仕様駆動開発で「仕様が先」と言っているのは、**人間が書くべき仕様の話** です。テストコードではなく、自然言語で書かれた仕様（Issue、受け入れ基準、DOMAIN.mdのルールなど）が先に存在すべきという意味です。

実際のワークフローでは、こう考えてください。

1. **人間が仕様を書く**：「パスワード誤り5回でロック」（Issueの受け入れ基準）
2. **AIがテストを生成**：仕様に基づいたテストコード
3. **AIが実装を生成**：テストを通す実装コード

この順序であれば、テストは「仕様の検証」として機能します。一方、テストコードだけを見て「これが仕様だ」と言われても、AIは文脈がわかりません。「なぜ5回なのか」「15分ロックの根拠は？」といった背景情報はテストコードには書かれていないからです。

TDDの「テストファースト」とAI仕様駆動開発の「仕様ファースト」は矛盾しません。人間が仕様を書き、AIがテストと実装を生成する。この分担がポイントです。

---

## ステップ3：AIにタスクを渡す

### プロンプトの構造

```markdown
## タスク
Issue #42 を実装してください。

## コンテキスト
- Issue: [IssueのURL or 内容をコピー]
- 関連文書:
  - docs/ARCHITECTURE.md
  - docs/DOMAIN.md
  - docs/PATTERNS.md

## 制約
- 既存の認証サービス（src/services/auth/）を拡張する形で実装
- 新規ファイルは src/services/auth/login.ts に作成
- テストは src/services/auth/__tests__/login.test.ts に作成

## 出力
1. 実装コード
2. テストコード
3. 影響を受ける既存ファイルの変更点
```

### AIコーディングツールを使う場合

Claude Code、GitHub Copilot、Cursorなど、いずれのツールでもIssueの内容をそのまま渡せます。

```bash
# Claude Codeの例
claude "Issue #42 を実装して。docs/配下の仕様に従って。"

# GitHub Copilot（チャット）の例
# @workspace Issue #42 を実装して。docs/配下の仕様に従って。
```

7文書がリポジトリにあれば、AIツールは自動的に参照します。

---

## ステップ4：70%完成度でPRを作成

### 完璧を求めない

AIが生成したコードを見て、「ここが微妙だな」と思うことがあるでしょう。

**そこで止まらないでください。**

70%の完成度でPRを出す理由：

1. **レビューで具体的な指摘を得られる**
2. **指摘内容がAIへの次の入力になる**
3. **完璧を目指す時間より、反復の方が速い**

### PRの書き方

```markdown
## PR #42: ログインAPIエンドポイントの実装

### 概要
Issue #42 の実装です。

### 変更内容
- `src/services/auth/login.ts`: ログインサービスを追加
- `src/api/routes/auth.ts`: ログインエンドポイントを追加
- `src/services/auth/__tests__/login.test.ts`: テストを追加

### 確認ポイント
- [ ] JWT署名がRS256になっているか
- [ ] ブルートフォース対策が正しく動作するか
- [ ] エラーレスポンスの形式が統一されているか

### 今後の対応（レビュー後）
- エッジケースの追加テスト
- パフォーマンス最適化（必要に応じて）

### 関連
- Closes #42
```

---

## ステップ5：レビュー→修正→マージ

### レビュー指摘をAIに渡す

レビューコメントは、**AIへの次の入力として最適** です。

```markdown
## レビュー指摘
「validateCredentials関数、バリデーションとDB問い合わせが混ざってる。分離して。」

## AIへの指示
上記のレビュー指摘に対応してください。
validateCredentials関数を以下のように分割してください：
1. validateLoginInput: 入力値のバリデーション
2. findUserByEmail: ユーザー検索
3. verifyPassword: パスワード検証

それぞれ単一責任になるよう実装してください。
```

レビュー指摘には**具体的な問題と期待される解決方向** が含まれているため、AIは的確に修正できます。

### 反復の効果

```text
1回目のPR → レビュー指摘5件
  ↓ AIで修正
2回目 → レビュー指摘2件
  ↓ AIで修正
3回目 → LGTM
```

反復するたびに、**スコープがさらに狭まる**ため、AIの出力精度は上がります。

---

## ステップ6：指摘をナレッジ化

### 繰り返される指摘を記録する

レビューで同じ指摘が何度も出る場合、それは**PATTERNS.mdに蓄積すべき知識** です。

```markdown
## よくある指摘と対応

### 関数の責務分離
❌ 1つの関数で複数のことをする
✅ 単一責任の関数に分割する

例：
- validateAndSave → validate + save
- fetchAndTransform → fetch + transform

### エラーレスポンスの統一
❌ throw new Error('message')
✅ return err(new SpecificError(details))

### テストの粒度
❌ 1つのテストで複数のケースをテスト
✅ 1テスト1ケース（Arrange-Act-Assert）
```

### 自動チェックへの昇格

何度も指摘されるパターンは、**自動チェックに組み込む**ことを検討します。

- ESLintカスタムルール
- pre-commitフック
- サブエージェントによるレビュー

これにより、「指摘される前に防ぐ」サイクルが回り始めます。

---

## 章末チェックリスト

- [ ] 次のタスクをIssueとして作成する
- [ ] Issueに「受け入れ基準」「技術的制約」「スコープ外」を含める
- [ ] **タスク種別に応じた必須参照文書を選択する**
- [ ] **関連Issueをリンクする**
- [ ] **読む必要のない文書を「スコープ外」に明記する**
- [ ] AIに渡す前に3つの確認（仕様・設計・テスト）を行う
- [ ] 70%完成度でPRを出す心構えを持つ
- [ ] レビュー指摘はAIへの入力として活用する
- [ ] 繰り返される指摘はPATTERNS.mdに記録する

---

## 🥷 AI侍道場 - Issueは芸術である

![AI侍道場：Issueは芸術である](../images/ch07-ai-samurai-dojo.png)

---

### 🗡️ AI侍の秘伝書

「芸術的なIssue」を書く3つの極意を授ける。

#### 秘伝その1：受け入れ基準はチェックリスト形式で

「ユーザー登録機能を作る」——これでは曖昧すぎる。**具体的な動作**をチェックリスト化せよ。

```markdown
## 受け入れ基準
- [ ] メールアドレスとパスワードで登録できる
- [ ] パスワードは8文字以上必須
- [ ] メールアドレス重複時は409エラーを返す
- [ ] 登録成功時は201とユーザー情報を返す
- [ ] 監査ログにイベントが記録される
```

チェックリスト形式なら、AIは「何が正しいか」を明確に理解できる。

#### 秘伝その2：技術的制約を明示せよ

「いい感じに実装して」ではAIは推測する。**使うべきライブラリ、従うべきパターン**を明示せよ。

```markdown
## 技術的制約
- パスワードハッシュはArgon2id（既存のhashServiceを使用）
- エラーレスポンスはsrc/errors/http.tsの形式に従う
- テストはArrange-Act-Assertパターンで書く
```

これで「プロジェクト固有のルール」を押さえた実装になる。

#### 秘伝その3：スコープ外を明記せよ

AIは「関連しそうなもの」を勝手に追加する。**今回作らないもの**を明示して、スコープを絞れ。

```markdown
## スコープ外
- メール確認フローは別Issue（#43）で対応
- ソーシャルログインは別Issue（#44）で対応
- パスワードリセットはPhase 2で対応
```

スコープを絞れば、PRが肥大化しない。

---
