# 3-1　スコープ収束パターン──小さく分けて精度を上げる

## ◼︎「全部やって」から「まず〇〇から」へ

1-1、2-1、2-2で、大きな事実が明らかになりました。

**1-1の発見**:
AIに「全部やって」と頼むと、70%の完成度で止まる。

**2-1の発見**:
即答型AIは「Lost in the Middle」──長い入力の中間部分を忘れやすい。

**2-2の発見**:
熟考型AIは「Lost at the Beginning」──最初の推論に引きずられやすい。

では、どうすればいいのでしょうか？

答えは、驚くほどシンプルです。

「**小さく分けて渡す**」

これだけです。

---

### 思い出してください

2-1・2-2で、こんな事実を学びました。

![大きなお願いvs小さなお願い](./images/03_big_vs_small_requests.png)

小さく分けると、**どちらの弱点も回避できます**。

- 即答型：「中間」がなくなる → 忘れない
- 熟考型：思考連鎖が短くなる → 最初の影響が限定的

各部分を98%の精度で処理できる。

この章では、この「小さく分ける」を
**具体的にどうやるか**を学んでいきます。

---

## ◼︎スコープ収束パターンとは

「小さく分けて渡す」という戦略には、名前があります。

**スコープ収束パターン**（Scope Convergence Pattern）

![スコープ収束パターン](./images/scope_convergence_pattern.png)

「**スコープ**」とは、作業の範囲のこと。
「**収束**」とは、小さな成功が積み重なって、大きな成果に収束していくこと。

大きなスコープを小さく分解し、
それぞれを高精度で完了させ、
最終的に大きな成果に収束させる。

これが「スコープ収束パターン」です。

---

### 70% → 90% → 98% の収束

スコープ収束パターンを使うと、
精度がどう変わるか見てみましょう。

![精度の収束イメージ](./images/03_precision_convergence.png)

一発で完璧を求めると、70%で止まる。
でも、小さなステップを積み重ねると、
**70% → 90% → 98%** と収束していきます。

これが「収束」の意味です。

---

## ◼︎なぜ「分ける」のか？──精度モードのWhy

「小さく分けて渡す」という戦略は、
「**何をしてほしいか**」を明確にするためだけではありません。

実は、「**なぜそうしてほしいか**」を伝えることで、
精度をさらに上げることができます。

```text
【What のみ vs What + Why】

❌ What のみ:
「ログイン機能を実装して」

✅ What + Why:
「ログイン機能を実装して。
 セキュリティを重視してほしい。
 理由：金融系サービスだから」
```

この2つ目の例では、AIは「セキュリティ重視」という
**判断基準**を持てます。

パスワードのハッシュ化、セッション管理の厳格さ、
二要素認証の検討──こうした判断を、
AIが自発的に行えるようになります。

「**小さく分ける**」+「**Whyを伝える**」

この組み合わせが、精度モードの本質です。

---

## ◼︎3つの基本ルール

スコープ収束パターンには、3つの基本ルールがあります。

---

### ルール1: 一度に1つだけ求める

最初のルールは、「**一度に1つだけ求める**」です。

```text
【ルール1の例】

❌ 悪い例:
「ログイン機能と、ログアウト機能と、
 パスワードリセット機能と、セッション管理を実装して」

✅ 良い例:
依頼1:「まず、ログイン機能を実装して」
依頼2:「次に、ログアウト機能を追加して」
依頼3:「次に、パスワードリセット機能を追加して」
依頼4:「最後に、セッション管理を追加して」
```

一度に複数のことを求めると、
AIは「中間」の情報を忘れやすくなります。

一度に1つだけ求めれば、
AIは**その1つに集中**できます。

---

### ルール2: 成功を確認してから次へ

2つ目のルールは、「**成功を確認してから次へ進む**」です。

```text
【ルール2の例】

❌ 悪い例:
依頼1 → 確認せず → 依頼2 → 確認せず → 依頼3
                                        ↓
                              問題が積み重なっている

✅ 良い例:
依頼1 → 確認 ✓ → 依頼2 → 確認 ✓ → 依頼3
   ↓           ↓           ↓
 問題なし     問題なし     問題なし
```

確認せずに次へ進むと、
最初の問題が後続のステップに影響します。

各ステップで確認することで、
**問題を早期に発見**し、修正できます。

---

### ルール3: 各ステップを検証可能にする

3つ目のルールは、「**各ステップを検証可能にする**」です。

```text
【ルール3の例】

❌ 検証しにくい出力:
「認証システムを実装しました」
→ 本当に正しいか、どう確認する？

✅ 検証しやすい出力:
「ログイン機能を実装しました。
 テスト用アカウント: test@example.com / password123
 以下のコマンドでテストできます: npm test」
→ 実際に試して確認できる
```

検証できない出力は、信頼できません。
各ステップの出力を**検証可能な形**にすることで、
本当に正しいかを確認できます。

この「検証可能にする」という考え方は、
次章の「二段階AI活用」でさらに深掘りします。

---

## ◼︎分野別の分け方ガイド

では、具体的にどう分ければいいのでしょうか？

分野ごとに「分け方」のパターンを見ていきましょう。

---

### テキスト生成の場合

**シナリオ**: 5000字のブログ記事を書いてもらう

```text
【従来のアプローチ】

「リモートワークの生産性について、
 5000字の包括的な記事を書いてください」

→ 70%の完成度
→ 中間部分が薄い
→ 結論が曖昧
```

```text
【スコープ収束パターン】

ステップ1:「この記事の見出し構成を5つ提案して」
    ↓ 確認 ✓
ステップ2:「見出し1の内容を800字で書いて」
    ↓ 確認 ✓
ステップ3:「見出し2の内容を800字で書いて」
    ↓ 確認 ✓
ステップ4:「見出し3の内容を800字で書いて」
    ↓ 確認 ✓
ステップ5:「見出し4の内容を800字で書いて」
    ↓ 確認 ✓
ステップ6:「見出し5の内容を800字で書いて」
    ↓ 確認 ✓
ステップ7:「全体を読み返して、導入と結論を調整して」

→ 98%の完成度
→ 各セクションが充実
→ 結論も明確
```

**ポイント**:

- 最初に「構成」を決める
- 各セクションを**個別に**書かせる
- 最後に**全体を調整**する

---

### コード生成の場合

**シナリオ**: REST APIの認証システムを実装してもらう

```text
【従来のアプローチ】

「JWT認証を使ったREST APIを実装して。
 ログイン、ログアウト、トークン更新、
 ロールベースアクセス制御も含めて」

→ 70%の完成度
→ 中間の機能が抜けている
→ テストがない
```

```text
【スコープ収束パターン】

ステップ1:「まず、認証関連の型定義を書いて」
    ↓ 確認 ✓（TypeScriptの型が正しいか確認）

ステップ2:「JWT（JSON Web Token）トークンの発行関数を書いて」
    ↓ 確認 ✓（トークン生成が動くか確認）

ステップ3:「ログインエンドポイントを実装して」
    ↓ 確認 ✓（実際にログインできるか確認）

ステップ4:「トークン検証ミドルウェアを実装して」
    ↓ 確認 ✓（保護されたルートにアクセスできるか確認）

ステップ5:「ロールベースのアクセス制御を追加して」
    ↓ 確認 ✓（権限チェックが動くか確認）

ステップ6:「テストコードを書いて」
    ↓ 確認 ✓（テストが通るか確認）

→ 98%の完成度
→ すべての機能が実装されている
→ テストもある
```

**ポイント**:

- **型定義から始める**（基盤を固める）
- 各機能を**独立して実装**
- **テストで検証**する

---

### 画像生成の場合

**シナリオ**: 会社のロゴを作成してもらう

```text
【従来のアプローチ】

「テック企業のロゴを作って。
 シンプルで、青系で、信頼感があって、
 モダンな感じで、アイコンも付けて」

→ 70%の完成度
→ イメージと違う
→ 10回修正しても微妙
```

```text
【スコープ収束パターン】

ステップ1:「ロゴのコンセプト案を3つ、
           テキストで説明して」
    ↓ 選択 ✓（案Bを選ぶ）

ステップ2:「案Bのカラーパレットを
           3パターン提案して」
    ↓ 選択 ✓（パレット2を選ぶ）

ステップ3:「案B + パレット2で、
           シンプルなロゴのラフ案を作って」
    ↓ 確認 ✓（方向性OK）

ステップ4:「ラフ案をベースに、
           細部を洗練させて」
    ↓ 確認 ✓（ほぼ完成）

ステップ5:「最終調整：文字の間隔を
           もう少し広げて」

→ 98%の完成度
→ 2-3回の修正で完成
→ イメージ通り
```

**ポイント**:

- **コンセプト**を最初に固める
- **カラー**を次に決める
- **詳細化**は最後に

---

### ドキュメント作成の場合

**シナリオ**: 新機能の提案書を作成してもらう

```text
【従来のアプローチ】

「新機能の提案書を作って。
 背景、課題、解決策、スケジュール、
 リスク、予算、期待効果を含めて」

→ 70%の完成度
→ 各セクションが浅い
→ 数字が曖昧
```

```text
【スコープ収束パターン】

ステップ1:「提案書の目次構成を作って」
    ↓ 確認 ✓（構成OK）

ステップ2:「『背景と課題』セクションを書いて」
    ↓ 確認 ✓（課題が明確）

ステップ3:「『解決策』セクションを書いて」
    ↓ 確認 ✓（解決策が具体的）

ステップ4:「『スケジュール』セクションを
           ガントチャート形式で作って」
    ↓ 確認 ✓（日程が現実的）

ステップ5:「『リスクと対策』セクションを
           表形式で作って」
    ↓ 確認 ✓（リスクが網羅的）

ステップ6:「『予算』と『期待効果』を
           数字を入れて作って」
    ↓ 確認 ✓（数字が具体的）

ステップ7:「全体を読み返して、
           エグゼクティブサマリーを作って」

→ 98%の完成度
→ 各セクションが充実
→ 数字が具体的
```

**ポイント**:

- **構成**を最初に決める
- **セクション単位**で作成
- **サマリー**は最後に

---

## ◼︎「分けすぎ」の罠

ここまで「小さく分ける」ことの重要性を説明してきました。

でも、**分けすぎにも問題**があります。

```text
【分けすぎの例】

❌ 分けすぎ:
「まず、関数名を決めて」
→「次に、引数を1つ追加して」
→「次に、引数をもう1つ追加して」
→「次に、戻り値の型を決めて」
→「次に、関数の1行目を書いて」
→「次に、関数の2行目を書いて」
→ ...

問題:
- 各ステップが小さすぎて、文脈が断絶
- AIが全体像を把握できない
- かえって非効率
```

---

### ちょうどいい粒度の見つけ方

では、どのくらいの粒度が適切なのでしょうか？

**目安**: 1つのお願いで、**1つの成果物**が得られる

```text
【粒度の判断基準】

✅ ちょうどいい粒度:
「ログイン機能を実装して」
→ 成果物: 動作するログイン機能（1つ）

❌ 細かすぎ:
「ログインボタンのHTMLを書いて」
→ 成果物: HTMLだけ（不完全）

❌ 大きすぎ:
「認証システム全体を実装して」
→ 成果物: 複数の機能（混在）
```

**もう1つの目安**: **検証できる単位**で分ける

```text
【検証できる単位で分ける】

✅ 検証できる:
「ログイン機能を実装して」
→ 実際にログインして確認できる

✅ 検証できる:
「パスワードのバリデーションを追加して」
→ 不正なパスワードを入力して確認できる

❌ 検証しにくい:
「セキュリティを向上させて」
→ 何をどう確認すればいい？
```

**粒度判断の目安まとめ**:

| 判断軸 | 良い粒度 | 悪い粒度 |
| :----- | :------- | :------- |
| 成果物 | 1つのお願い = 1つの成果物 | 複数の成果物が混在 / 不完全な断片 |
| 検証性 | すぐに動作確認できる | 「何をどう確認？」と迷う |
| 独立性 | そのステップだけで意味がある | 前後がないと意味不明 |
| 時間感覚 | 5〜15分で完了できる | 数秒で終わる / 1時間以上かかる |

---

### 分け方のチェックリスト

迷ったときは、このチェックリストを使ってください。

```text
【分け方のチェックリスト】

□ 1つのお願いで、1つの成果物が得られるか？
□ その成果物を、すぐに検証できるか？
□ 分けた各ステップが、独立して意味を持つか？
□ ステップ間の依存関係が明確か？
□ 全体として、元のゴールを達成できるか？
```

---

## ◼︎まとめ：分野別スコープ収束パターン早見表

| 分野 | Before（70%） | After（98%） | 分け方のコツ |
| :----- | :-------------- | :------------- | :------------- |
| テキスト | 「5000字の記事を書いて」 | 構成→各セクション→調整 | 構成が先、詳細は後 |
| コード | 「認証システム全体を」 | 型定義→機能→テスト | 基盤から積み上げ |
| 画像 | 「ロゴを作って」 | コンセプト→カラー→詳細 | 抽象から具体へ |
| 文書 | 「提案書を作って」 | 目次→各セクション→サマリー | 構成が先、サマリー最後 |

**共通するポイント**: どの分野でも「**全体構成を先に決め、各部分を個別に作り、最後に調整する**」という流れが有効。

<div class="column-box">

### 🧳 コラム：スーツケースパンパン問題

![スーツケースパンパン問題](./images/column_03-1_suitcase.png)

**教訓**: 一気に詰め込むと溢れる。一枚ずつ丁寧に畳めば、全部収まって余裕もできる！旅行もAIも、焦りは禁物🧳

</div>
