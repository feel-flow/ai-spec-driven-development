# 第5-1章　ファイル整理の技術──AIが扱いやすい情報のまとめ方

## 5.1　導入：なぜ「ファイルの整理」がAI活用の鍵なのか

### 「ファイル」という単位で考える

ここまで、「コンテキストを小さくする」ことの重要性を繰り返し述べてきました。

では、実際に「コンテキストを小さくする」とは、具体的に何を意味するのでしょうか。

答えは**ファイル整理**です。

AIに何かを頼むとき、私たちは「ファイル」を渡しています。

- WordファイルをChatGPTに貼り付ける
- PDFをClaudeに読ませる
- フォルダの中身を見せて整理を依頼する

これらはすべて「**ファイルを渡す**」行為です。

### 大きなファイル = AIの苦手な「長い入力」

第2-1章で学んだ「Lost in the Middle」問題を思い出してください。

AIは、長い入力の**中間部分を忘れやすい**という弱点があります。

つまり、大きなファイルを渡すと：
- 最初の方は覚えている
- **中間部分を忘れる** ← ここが問題
- 最後の方は覚えている

1000行のファイルも、100行×10個のファイルも、情報量は同じです。でも、AIにとっては後者の方が扱いやすいのです。

### ファイル整理 = コンテキスト縮小戦略の実践

ファイルを整理する＝**AIが処理しやすい形にする**＝精度が上がる

これが本章のテーマです。

開発者でなくても、日々の業務でファイルを扱う人なら、この考え方は役立ちます。

---

## 5.2　テキストファイルの基本──AIが読める形式

### なぜテキストデータが重要か

AIは**テキスト**を「読んで」処理します。

画像やPDFを渡すと、AIはまず「文字起こし」をしてから処理します。この変換過程で情報が失われることがあります。

**最初からテキストで渡せば、精度が上がる**のです。

| 形式 | AIの処理 | 精度 |
|-----|---------|------|
| テキストファイル | そのまま読む | 高い |
| Word/Excel | 変換してから読む | やや低い |
| PDF | 変換してから読む | やや低い |
| 画像（スキャン） | OCRで文字起こし | 低い |

### Markdown形式とは

**Markdown**（マークダウン）は、シンプルな記法で文書の構造を表現できる形式です。

```markdown
# 見出し1
## 見出し2
### 見出し3

- 箇条書き1
- 箇条書き2

**太字**で強調

1. 番号付きリスト
2. 番号付きリスト
```

この本も、Markdown形式で書かれています。

**Markdownの利点**：
- 見た目を気にせず、**内容に集中**できる
- AIが**構造を理解しやすい**
- どんなテキストエディタでも開ける
- バージョン管理がしやすい

### Word/Excelとの違い

| | Word/Excel | テキスト（Markdown） |
|---|-----------|------------------|
| 見た目 | 重視 | 最小限 |
| ファイルサイズ | 大きい | 小さい |
| AIへの渡しやすさ | 変換が必要 | そのまま |
| 編集ツール | 専用ソフト | 何でもOK |

「見た目を整える」より「内容を整理する」方が、AIとの作業では重要です。

---

## 5.3　VS Code入門──AIと連携できるファイル管理ツール

### VS Codeとは

**VS Code**（Visual Studio Code）は、Microsoftが作った**無料のテキストエディタ**です。

「プログラマー向けのツールでしょ？」と思われがちですが、実は**誰でも使えるファイル管理ツール**として優れています。

**VS Codeでできること**：
- フォルダを開いて、中のファイルを一覧表示
- テキストファイル（Markdown含む）の編集
- 複数ファイルの同時編集
- **AIとの連携**（Claude Code、GitHub Copilotなど）

### なぜAI時代にVS Codeが便利か

現在、AIと連携できるファイル管理ツールは限られています。VS Codeは、その中で最も充実した環境を提供しています。

**AIツールとの連携**：
- **Claude Code**：@ファイル名でファイルを参照できる
- **GitHub Copilot**：コードの補完と提案
- **Cursor**：AIファーストのエディタ（VS Codeベース）

これらのツールは、VS Codeのフォルダ構造を理解して、必要なファイルだけを参照できます。

### インストール方法

1. [code.visualstudio.com](https://code.visualstudio.com/) からダウンロード
2. インストーラーを実行
3. 日本語化：拡張機能から「Japanese Language Pack」をインストール

### 最初の一歩

1. VS Codeを起動
2. 「フォルダーを開く」で作業フォルダを選択
3. 左側のエクスプローラーでファイル一覧を確認
4. 新規ファイル作成（右クリック→「新しいファイル」）

**ポイント**：VS Codeは「フォルダ単位」で作業します。まずフォルダを開くことから始めましょう。

---

## 5.4　ファイルサイズの重要性──大きいファイルが良くない理由

### Lost in the Middleの復習

第2-1章で学んだ内容を簡潔に振り返ります。

AIは、長い入力の**中間部分を忘れやすい**という特性があります。

- 入力の最初：よく覚えている
- 入力の中間：**忘れやすい**
- 入力の最後：よく覚えている

これは「Lost in the Middle」問題と呼ばれています。

### 1ファイルの目安

経験則として、**1ファイル500行以下**がAIとの作業に適したサイズです。

| ファイルサイズ | AI精度 | 目安 |
|--------------|--------|------|
| 〜200行 | 非常に高い | A4で2枚程度 |
| 200〜500行 | 高い | A4で5枚程度 |
| 500〜800行 | やや低下 | A4で8枚程度 |
| 800行〜 | 低下 | それ以上 |

**業務文書なら「A4で5枚程度」**が目安になります。

### 大きくなったら分割するサイン

以下のような状況になったら、ファイルを分割するタイミングです：

- **スクロールが多くなった**
  - 「あの部分どこだっけ？」と探すことが増えた

- **複数のテーマが混在している**
  - 1つのファイルに「会議記録」と「タスク一覧」と「参考資料」が入っている

- **AIに渡すと中間が無視される**
  - 「ここも読んでほしかったのに」と思うことが増えた

---

## 5.5　分割の基本原則──1ファイル = 1テーマ

### 「買い物袋」の比喩

第1-1章のコラムで「買い物袋」の話をしました。

1つの袋に全部詰め込むと：
- 重くて持てない
- 卵が割れる
- 欲しいものが見つからない

ファイルも同じです。

**1ファイル = 1テーマ**にすれば：
- 必要な情報だけを渡せる
- AIが迷わない
- 修正も楽

### 業務ファイルの分割例

#### 議事録の場合

**Before**（すべて1ファイル）：
```text
meeting_notes.md
├── 2024年1月の会議（500行）
├── 2024年2月の会議（400行）
├── 2024年3月の会議（600行）
└── 合計1500行 → AIが中間を忘れる
```

**After**（会議ごとに分割）：
```text
meetings/
├── 2024-01_monthly.md（500行）
├── 2024-02_monthly.md（400行）
└── 2024-03_monthly.md（600行）
```

AIに「3月の会議について確認して」と頼むとき、3月のファイルだけを渡せます。

#### 企画書の場合

**Before**（1つの長い文書）：
```text
企画書.md
├── 背景・課題
├── 解決策
├── スケジュール
├── 予算
├── リスク
└── 合計800行 → 長すぎ
```

**After**（セクションごとに分割、または構造化）：
```text
proposal/
├── 01_background.md（背景・課題）
├── 02_solution.md（解決策）
├── 03_schedule.md（スケジュール）
├── 04_budget.md（予算）
└── 05_risk.md（リスク）
```

または、1ファイルのまま500行以内に収まるなら、見出しで構造化するだけでもOKです。

#### マニュアルの場合

**Before**：
```text
操作マニュアル.md（2000行）
```

**After**：
```text
manual/
├── 01_getting_started.md（はじめに）
├── 02_basic_operations.md（基本操作）
├── 03_advanced.md（応用機能）
└── 04_troubleshooting.md（トラブル対応）
```

### 分割しすぎない

分割しすぎると、今度は「情報が分散しすぎて、必要な情報を伝えにくい」という問題が発生します。

**分割しすぎのサイン**：
- 1つの作業で3ファイル以上を開く必要がある
- 分割後のファイルが50行以下になる
- 「あのファイルとこのファイルは常にセットで見る」状態

**バランスのポイント**：
- 一緒に変更される情報は、同じファイルに置く
- 独立して変更される情報は、別ファイルに分ける

---

## 5.6　AIへの渡し方──効果的なファイル参照

### 「全体像」を先に伝える

AIにファイルを渡す前に、プロジェクトの全体像を伝えると精度が上がります。

```text
【効果的な伝え方】

このフォルダには、新製品企画のドキュメントが入っています。
構成は以下の通りです：

proposal/
├── 01_background.md → 背景・課題
├── 02_solution.md   → 解決策
├── 03_schedule.md   → スケジュール
└── 04_budget.md     → 予算

今から「02_solution.md」の内容を確認してください。
このファイルは、課題に対する解決策を説明しています。
```

**なぜ効果的か**：
- AIが「このファイルの役割」を理解できる
- 他のファイルとの関係がわかる
- 文脈を踏まえた回答ができる

### 渡すファイルは3〜5個まで

1つのファイルだけでは情報が足りない場合、関連ファイルも渡します。

ただし、**渡しすぎないことが重要**です。

**推奨**：
```text
02_solution.md について確認してください。

関連ファイル：
- 01_background.md（背景情報）
```

**非推奨**：
```text
02_solution.md について確認してください。

関連ファイル：
- 01_background.md
- 03_schedule.md
- 04_budget.md
- 過去の企画書10個
- 参考資料20個
→ 多すぎてAIの弱点が発生（中間忘却）
```

**目安**：
- 渡すファイルは**3〜5個まで**
- 本当に必要なファイルだけを選ぶ
- 迷ったら「このファイルがないと作業できないか？」で判断

### @参照の使い方（VS Code + Claude Code）

VS Code + Claude Code では、`@ファイル名` でファイルを参照できます。

```text
@proposal/02_solution.md の内容を要約してください。
参考: @proposal/01_background.md
```

この機能を効果的に使うコツ：

1. **必要なファイルだけを参照する**
2. **参照の順序を意識する**（メインのファイルを最初に）
3. **参照理由を明記する**（「参考:」「背景情報:」など）

---

## 5.7　【コラム】AIにファイル整理を手伝ってもらう

<div class="column-box">

### 📂 コラム：AIにファイル整理を手伝ってもらう

本書の「小さく分ける」とは少し違う使い方ですが、AIは「ファイルの整理」そのものも手伝ってくれます。

**フォルダ分けの提案をもらう**：
```text
このフォルダにあるファイル一覧から、
整理案を提案してください。

- 報告書_2024年1月.docx
- 報告書_2024年2月.docx
- 議事録_営業会議.md
- 議事録_開発会議.md
- 参考資料_競合分析.pdf
- 参考資料_市場調査.pdf
```

**ファイル名の命名規則を作る**：
```text
議事録のファイル名ルールを提案してください。
以下の条件を満たしたいです：
- 日付がわかる
- 会議の種類がわかる
- 時系列で並ぶ
```

これは「AIに実行させる」というより「**AIに提案してもらう**」使い方です。第4部で学んだ「推論モード」の応用ですね。

**AI侍**: 「整理の仕方を考えてもらうのも、立派なAI活用じゃ」
**DJ町娘**: 「自分で全部考えなくていいんですね！」

</div>

---

## 5.8　【補足】システム開発での応用

### 開発者向けの内容

ここからは、システム開発者向けの補足です。業務ファイル整理の原則は、コードにもそのまま当てはまります。

### ファイル分割の3つの軸

開発プロジェクトでは、主に3つの軸でファイルを分割します：

**1. 機能単位で分ける**
```text
features/
├── authentication/（認証機能）
├── payment/（決済機能）
└── notification/（通知機能）
```

**2. レイヤー単位で分ける**
```text
src/
├── domain/（ビジネスロジック）
├── application/（ユースケース）
├── infrastructure/（外部連携）
└── presentation/（UI/API）
```

**3. ドメイン単位で分ける**
```text
src/
├── user/（ユーザードメイン）
├── order/（注文ドメイン）
└── payment/（決済ドメイン）
```

### プロンプトの書き方

**悪い例**：
```text
認証機能を改善してください。
```

**良い例**：
```text
@src/auth/login.ts の login関数に以下の修正を加えてください：
1. ログイン試行回数のチェックを追加
2. 5回失敗したら15分間ロック
3. 成功したらカウンターをリセット

参考: @src/utils/rate-limiter.ts
```

開発での詳しい活用方法は、姉妹編「AIエージェント開発は仕様が9割」で解説しています。

---

## 5.9　この本の壁打ち例（メタな紹介）

### この本はAIとの壁打ちで生まれた

実は、この本自体がAI（Claude）との壁打ちで執筆されています。ここでは、その過程を「メタ」に紹介します。

### 章構成の決め方

本書の章構成は、以下のようなAIとの対話で決まりました。

```markdown
【人間の最初のお願い】
AIを使うのがうまくいかない理由と、うまく使うコツを
本にまとめたいと思っています。構成を考えてください。

【AIの提案】
（複数の構成案を提示）

【人間の壁打ち】
「なんか違う」と感じた部分を具体的にフィードバック：
- 「第3部と第4部の対比がわかりにくい」
- 「AIの弱点は重要なので独立した章に」
- 「実践編が欲しい」

【AIの修正案】
（フィードバックを反映した構成案）

【繰り返し】
3〜4回のやり取りで、現在の6部構成に
```

**ポイント**：
- 一度で完璧を求めなかった
- 「なんか違う」を具体化して伝えた
- AIの提案を叩き台にして、人間が判断した

### 用語の統一方法

本書では、用語統一のために `terminology.yaml` を作成しています。

```yaml
# terminology.yaml（抜粋）
core_concepts:
  - standard: "70%問題"
    variants:
      - "70%の完成度"
      - "七割問題"
    description: "AIに大きなタスクを丸投げすると、
                  約70%の完成度で止まってしまう現象"

  - standard: "Lost in the Middle"
    variants:
      - "Lost in the Middle問題"
      - "ロスト・イン・ザ・ミドル"
    description: "即答型AIが長い入力の中間部分を忘れやすい問題"
```

この用語集は、以下の手順で作成しました：

1. **AIに本文から用語を抽出させる**
2. **人間が確認・修正**
3. **AIに用語集を使って校正させる**

### 校正プロセス

本書の校正は、二段階AI活用パターン（第3-2章）を実践しています。

```markdown
【第一段階：AIにチェックリストを作らせる】
人間: この章を校正するためのチェックリストを作ってください。

AI: 以下の観点でチェックします：
1. 日本語表現（誤字脱字、文法）
2. 用語統一（terminology.yaml準拠）
3. 章構造（必須セクションの有無）
4. Markdown形式（コードブロック、リンク）
5. ファクトチェック（引用の正確性）

【第二段階：チェックリストで人間が検証】
人間: AIの指摘を確認し、実際に修正が必要か判断
```

**この方法のメリット**：
- AIの「見落とし」を人間がカバー
- AIの「過剰な指摘」を人間がフィルタリング
- 最終判断は人間が行う

### ファイル分割の実践

本書自体も、ファイル分割の原則に従っています。

```text
books/ai-small-is-accurate/
├── 00_toc.md                     (目次)
├── 00_preface.md                 (まえがき)
├── part1_why-ai-fails/
│   ├── 01-1_the-seventy-percent-problem.md
│   └── 01-2_hidden-costs-and-solutions.md
├── part2_context-limit/
│   ├── 02-1_lost-in-the-middle.md
│   └── 02-2_lost-at-the-beginning.md
├── part3_precision/
│   ├── 03-1_scope-convergence.md
│   └── 03-2_two-stage-ai.md
├── part4_inference/
│   └── 04-1_leave-room-for-thinking.md
├── part5_vscode/
│   └── 05-1_practical-tips.md（この章）
├── part6_new-roles/
│   └── 06-1_human-as-divider.md
└── appendix_quick-reference.md
```

**分割のポイント**：
- 各章は500〜800行に収める
- 長くなった第1章は01-1と01-2に分割
- 部（Part）ごとにディレクトリを分ける
- AIに「この章を校正して」と渡しやすいサイズ

---

## 5.10　章末チェックリスト

### ファイル整理のチェックリスト

- [ ] 1ファイル = 1テーマになっているか
- [ ] 各ファイルは500行（A4で5枚）以下か
- [ ] ファイル名から内容が推測できるか
- [ ] 関連する情報は近くに配置されているか

### AIへの渡し方チェックリスト

- [ ] 全体像を先に伝えたか
- [ ] 渡すファイルは3〜5個以内か
- [ ] 参照理由を明記したか
- [ ] 指示は具体的で小さいか

### Markdown活用チェックリスト

- [ ] テキスト形式で保存しているか
- [ ] 見出し（#）で構造を整理しているか
- [ ] 箇条書きを効果的に使っているか

---

<div class="column-box">

### 🧰 コラム：職人の道具箱

大工さんの道具箱を見たことがありますか？

のこぎり、かんな、ハンマー、それぞれが**専用の役割**を持っています。大工さんは、作業内容に応じて道具を選びます。

ファイル整理も同じです。1つのファイルに全部を詰め込むのではなく、役割ごとに分けることで、AIに「今はこの道具だけ使って」と指示できるようになります。

「ファイル整理 = AIのための道具箱づくり」なのです。

**AI侍**: 「職人は道具を見ればその腕がわかる。ファイル整理も同じじゃ」
**DJ町娘**: 「役割ごとに分けておけば、AIに『この道具だけ使って』って指示できるんですね！」

</div>
