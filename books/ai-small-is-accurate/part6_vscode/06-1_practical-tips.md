# 第6-1章　ファイル分割の技術──AIが見える範囲を設計する

## 6.1　導入：ファイル分割とAIの関係

### なぜファイル分割が重要なのか

ここまで、「コンテキストを小さくする」ことの重要性を繰り返し述べてきました。では、実際の開発環境で「コンテキストを小さくする」とは、具体的に何を意味するのでしょうか。

答えは**ファイル分割**です。

AIツールにとって、「見える範囲」とはファイルです。1つの大きなファイルに全てを詰め込めば、AIは大量のコンテキストを処理しなければなりません。第2-1章・第2-2章で学んだAIの弱点（中間忘却・最初の推論依存）が発生し、精度が下がってしまいます。

逆に、適切なサイズにファイルを分割すれば、AIは必要な情報だけを見て、正確に作業できます。

![大きなファイル vs 分割されたファイル。大きな2000行のファイルはAIが中間を忘れて精度が下がるが、200-300行に分割されたファイルならAIは必要なファイルだけを見て精度が上がる。](./06_file_splitting_effect.png)

### ファイル = コンテキストウィンドウ

VSCode + AI（Claude Code, GitHub Copilot, Cursor など）を使う場合、AIが「見ている」のは主に以下のものです。

1. **現在開いているファイル**
2. **明示的に参照したファイル**（@ファイル名など）
3. **プロジェクトの構造情報**（ファイル一覧、ディレクトリ構造）

つまり、ファイル設計 = AIのコンテキスト設計なのです。

良いファイル設計ができていれば、AIに「このファイルを見て」と渡すだけで、必要十分な情報が伝わります。悪いファイル設計だと、AIに大量のコンテキストを渡すか、重要な情報を伝え忘れるか、どちらかの問題が発生します。

---

## 6.2　ファイル分割の基本原則

### 原則1：1ファイル = 1責務

ソフトウェア設計の「単一責任原則（Single Responsibility Principle）」は、AI時代においてさらに重要になります。

![1ファイル複数責務 vs 責務ごとに分割。悪い例では1000行を超えてAIが全体を把握しにくいが、良い例では責務ごとに分割して各ファイル200-300行でAIが正確に把握できる。](./06_responsibility_split.png)

### 原則2：500行以下を目安に

経験則として、**1ファイル500行以下**がAIとの作業に適したサイズです。

| ファイルサイズ | AI精度 | 推奨度 |
|--------------|--------|--------|
| 〜200行      | 非常に高い | ◎ |
| 200〜500行   | 高い      | ○ |
| 500〜800行   | やや低下  | △ |
| 800行〜      | 低下      | × |

800行を超えたら、分割を検討すべきサインです。

### 原則3：関連する情報は近くに置く

分割しすぎると、今度は「情報が分散しすぎて、AIに必要な情報を伝えにくい」という問題が発生します。

![過度な分割 vs 適度なグループ化。悪い例では8ファイルに分散して1つの変更で複数ファイルを渡す必要があるが、良い例では4ファイルに集約して関連情報が近くにある。](./06_grouping_balance.png)

**バランスのポイント**：
- 一緒に変更される情報は、同じファイルに置く
- 独立して変更される情報は、別ファイルに分ける

### 原則4：AIに渡すときのコンテキスト設計

ファイル分割を考えるとき、「このファイルをAIに渡したとき、何が伝わるか」を意識しましょう。

**良いファイルの特徴**：
- ファイル名から内容が推測できる
- ファイルの先頭に概要コメントがある
- 依存関係が明確（import文を見れば関連がわかる）
- 1つのファイルを読めば、1つの機能が理解できる

```typescript
/**
 * user/authentication.ts
 *
 * ユーザー認証に関する処理を提供する。
 * - ログイン（メール + パスワード）
 * - ログアウト
 * - トークン検証
 *
 * 依存: jwt-utils, user-repository
 */

import { verifyToken, generateToken } from '../utils/jwt-utils';
import { findUserByEmail, updateLastLogin } from './user-repository';

// 以下、認証に関する関数のみ
```

---

## 6.3　どう分けるか：分割の判断基準

### 3つの分割軸

ファイルを分割するとき、主に3つの軸で考えます。

#### 軸1：機能単位で分ける

**最も直感的な分け方**です。「何をするか」でファイルを分けます。

```
features/
├── authentication/     (認証機能)
│   ├── login.ts
│   └── logout.ts
├── payment/            (決済機能)
│   ├── checkout.ts
│   └── refund.ts
└── notification/       (通知機能)
    ├── email.ts
    └── push.ts
```

**メリット**：
- 直感的でわかりやすい
- 機能追加時に新しいディレクトリを作るだけ

**デメリット**：
- 機能間で共通処理が重複しやすい

#### 軸2：レイヤー単位で分ける

**アーキテクチャに基づく分け方**です。クリーンアーキテクチャやレイヤードアーキテクチャでよく使われます。

```
src/
├── domain/          (ビジネスロジック)
│   ├── user.ts
│   └── order.ts
├── application/     (ユースケース)
│   ├── create-user.ts
│   └── place-order.ts
├── infrastructure/  (外部連携)
│   ├── database.ts
│   └── api-client.ts
└── presentation/    (UI/API)
    ├── user-api.ts
    └── order-api.ts
```

**メリット**：
- 責務が明確に分離される
- テストがしやすい

**デメリット**：
- 1つの機能を追うために複数レイヤーを見る必要がある

#### 軸3：ドメイン単位で分ける

**ビジネス領域に基づく分け方**です。大規模なプロジェクトで有効です。

```
src/
├── user/           (ユーザードメイン)
│   ├── domain/
│   ├── application/
│   └── infrastructure/
├── order/          (注文ドメイン)
│   ├── domain/
│   ├── application/
│   └── infrastructure/
└── payment/        (決済ドメイン)
    ├── domain/
    ├── application/
    └── infrastructure/
```

**メリット**：
- ドメインごとに独立して開発できる
- チーム分割がしやすい

**デメリット**：
- 初期設計が大変
- ドメイン間の連携が複雑になりやすい

### 分割の粒度チェックリスト

ファイルを分割すべきかどうか、以下のチェックリストで判断しましょう。

**分割すべきサイン**：
- [ ] ファイルが500行を超えている
- [ ] 1つのファイルに複数の「機能」がある
- [ ] ファイル名が曖昧（`utils.ts`、`helpers.ts`など）
- [ ] 変更時に「関係ない部分」も目に入る
- [ ] AIに渡すと「余計な情報」も含まれる

**分割すべきでないサイン**：
- [ ] 分割すると、1つの変更で3ファイル以上を編集する
- [ ] 分割後のファイルが50行以下になる
- [ ] 密接に連携するコードが離れてしまう

---

## 6.4　どう渡すか：AIへの効果的な渡し方

### 全体像を先に伝える

AIにファイルを渡す前に、プロジェクトの全体像を伝えると精度が上がります。

```markdown
【効果的な伝え方】

このプロジェクトは、ECサイトのバックエンドです。
構成は以下の通りです：

src/
├── user/       → ユーザー管理
├── product/    → 商品管理
├── order/      → 注文管理
└── payment/    → 決済処理

今から @src/order/checkout.ts を修正します。
このファイルは、カート内の商品を注文に変換する処理を担当しています。
```

**なぜ効果的か**：
- AIが「このファイルの役割」を理解できる
- 他のファイルとの関係がわかる
- 修正の影響範囲を予測できる

### 関連ファイルを明示する

1つのファイルだけでは情報が足りない場合、関連ファイルも渡します。ただし、渡しすぎないことが重要です。

```markdown
【推奨】
@src/order/checkout.ts を修正してください。

関連ファイル：
- @src/order/types.ts （型定義）
- @src/payment/stripe.ts （決済処理）

---

【非推奨】
@src/order/checkout.ts を修正してください。

関連ファイル：
- @src/order/types.ts
- @src/order/repository.ts
- @src/order/service.ts
- @src/payment/stripe.ts
- @src/payment/types.ts
- @src/user/repository.ts
- @src/product/repository.ts
- @src/notification/email.ts
→ 多すぎてAIの弱点が発生（中間忘却・最初の推論依存）
```

**目安**：
- 渡すファイルは**3〜5個まで**
- 本当に必要なファイルだけを選ぶ
- 迷ったら「このファイルがないと作業できないか？」で判断

### @ファイル参照の活用（VSCode + Claude Code）

VSCode + Claude Code では、`@ファイル名` でファイルを参照できます。

```
@src/user/authentication.ts のlogin関数にレート制限を追加してください。
参考: @src/utils/rate-limiter.ts
```

この機能を効果的に使うコツ：

1. **必要なファイルだけを参照する**
   - 「関連しそう」ではなく「必要」なファイルを選ぶ

2. **参照の順序を意識する**
   - 修正対象ファイルを最初に
   - 参考ファイルを後に

3. **参照理由を明記する**
   - 「参考:」「型定義:」「依存:」など

### コンテキストの優先順位

AIに渡す情報には、優先順位があります。

![コンテキスト配分の優先順位と目安。優先順位は高い順に、修正対象のファイル、直接依存するファイル、型定義ファイル、関連するテストファイル、設定ファイル、READMEや仕様書。配分の目安は修正対象50%、直接依存30%、型定義10%、その他10%。](./06_context_priority.png)

---

## 6.5　VSCode + Claude Codeの実践

### セットアップと基本操作

Claude Codeは、VSCodeの拡張機能として動作するAIアシスタントです。以下の特徴があります。

- ファイルシステムへのアクセス
- ターミナルでのコマンド実行
- @参照によるファイル指定
- 会話の文脈を保持

基本的な使い方：

```markdown
1. Claude Codeを起動
2. プロジェクトの概要を伝える
3. 修正対象ファイルを @参照で指定
4. 具体的な指示を出す
5. 結果を確認して、必要なら追加指示
```

### ファイル参照の方法

Claude Codeでファイルを参照する方法は複数あります。

| 方法 | 説明 | 使いどころ |
|------|------|-----------|
| `@ファイルパス` | 特定のファイルを参照 | 修正対象を指定 |
| `@フォルダ/` | ディレクトリ構造を参照 | 全体像を伝える |
| コードブロック貼り付け | 直接コードを渡す | 部分的な情報を渡す |
| ファイルを開く | 開いているファイルをコンテキストに | 現在の作業対象 |

**効果的な組み合わせ例**：

```markdown
【シナリオ】ユーザー認証にOAuth対応を追加

まず全体像を確認します：
@src/auth/

次に修正対象を見ます：
@src/auth/login.ts

参考にする既存実装：
@src/auth/jwt-auth.ts

このlogin.tsに、Google OAuthでのログイン機能を追加してください。
jwt-auth.tsのパターンを参考に、oauth-login関数を作成してください。
```

### 効果的なプロンプトの書き方

AIへの指示は、本書で学んだ原則に従います。

**悪い例：曖昧で大きなお願い**
```
認証機能を改善してください。
```

**良い例：具体的で小さなお願い**
```
@src/auth/login.ts の login関数に以下の修正を加えてください：

1. ログイン試行回数のチェックを追加
2. 5回失敗したら15分間ロック
3. 成功したらカウンターをリセット

参考: @src/utils/rate-limiter.ts のrateLimitCheck関数
```

**さらに良い例：検証可能な形で**
```
@src/auth/login.ts にレート制限を追加します。

まず、以下のテストケースを @src/auth/__tests__/login.test.ts に追加してください：
1. 5回連続で失敗 → ロックされる
2. 4回失敗 → まだログイン可能
3. ロック中にログイン → エラーメッセージ
4. 15分後 → ロック解除

その後、テストが通るようにlogin関数を修正してください。
```

### よくある落とし穴と対策

#### 落とし穴1：ファイルを渡しすぎる

```markdown
【問題】
@src/ 全体を参照して、バグを見つけてください。

【対策】
@src/order/checkout.ts の calculateTotal関数で、
税計算が間違っているようです。確認してください。
```

#### 落とし穴2：曖昧な指示

```markdown
【問題】
このコードをもっと良くしてください。

【対策】
@src/user/profile.ts のupdateProfile関数に、
以下のバリデーションを追加してください：
- メールアドレスの形式チェック
- 名前の文字数チェック（1〜50文字）
```

#### 落とし穴3：複数の修正を一度に頼む

```markdown
【問題】
認証、決済、通知の機能を全部リファクタリングしてください。

【対策】
@src/auth/login.ts のリファクタリングをお願いします。
（他の機能は後で別々に依頼）
```

#### 落とし穴4：コンテキストの継続を期待しすぎる

```markdown
【問題】
（長い会話の後で）
さっきの続きで、あれも直してください。

【対策】
@src/auth/login.ts のlogin関数について、
先ほど追加したレート制限に加えて、
IPアドレスベースのブロック機能も追加してください。
```

---

## 6.6　この本の壁打ち例（メタな紹介）

### この本はAIとの壁打ちで生まれた

実は、この本自体がAI（Claude）との壁打ちで執筆されています。ここでは、その過程を「メタ」に紹介します。

### 章構成の決め方

本書の章構成は、以下のようなAIとの対話で決まりました。

```markdown
【人間の最初のお願い】
AIを使うのがうまくいかない理由と、うまく使うコツを
本にまとめたいと思っています。構成を考えてください。

【AIの提案】
（複数の構成案を提示）

【人間の壁打ち】
「なんか違う」と感じた部分を具体的にフィードバック：
- 「第3部と第4部の対比がわかりにくい」
- 「AIの弱点は重要なので独立した章（2章・2b章）に」
- 「実践編が欲しい」

【AIの修正案】
（フィードバックを反映した構成案）

【繰り返し】
3〜4回のやり取りで、現在の7部構成に
```

**ポイント**：
- 一度で完璧を求めなかった
- 「なんか違う」を具体化して伝えた
- AIの提案を叩き台にして、人間が判断した

### 用語の統一方法

本書では、用語統一のために `terminology.yaml` を作成しています。

```yaml
# terminology.yaml（抜粋）
core_concepts:
  - standard: "70%問題"
    variants:
      - "70%の完成度"
      - "七割問題"
    description: "AIに大きなタスクを丸投げすると、約70%の完成度で止まってしまう現象"

  - standard: "Lost in the Middle"
    variants:
      - "Lost in the Middle問題"
      - "ロスト・イン・ザ・ミドル"
    description: "即答型AIが長い入力の中間部分を忘れやすい問題"

  - standard: "Lost at the Beginning of Reasoning"
    variants:
      - "Lost at the Beginning"
      - "ロスト・アット・ザ・ビギニング"
    description: "熟考型AIが最初の推論ステップに引きずられやすい問題"
```

この用語集は、以下の手順で作成しました：

1. **AIに本文から用語を抽出させる**
   - 「本文を読んで、繰り返し出てくる用語をリストアップして」

2. **人間が確認・修正**
   - 標準表記を決定
   - 不要な用語を削除

3. **AIに用語集を使って校正させる**
   - 「この用語集に従って、本文の表記揺れをチェックして」

### 校正プロセス

本書の校正は、二段階AI活用パターン（第3-2章）を実践しています。

```markdown
【第一段階：AIにチェックリストを作らせる】
人間: この章を校正するためのチェックリストを作ってください。

AI: 以下の観点でチェックします：
1. 日本語表現（誤字脱字、文法）
2. 用語統一（terminology.yaml準拠）
3. 章構造（必須セクションの有無）
4. Markdown形式（コードブロック、リンク）
5. ファクトチェック（引用の正確性）

---

【第二段階：チェックリストで人間が検証】
人間: AIの指摘を確認し、実際に修正が必要か判断
```

**この方法のメリット**：
- AIの「見落とし」を人間がカバー
- AIの「過剰な指摘」を人間がフィルタリング
- 最終判断は人間が行う

### ファイル分割の実践

本書自体も、ファイル分割の原則に従っています。

```
books/ai-small-is-accurate/
├── 00_toc.md                     (目次: 〜100行)
├── 00_preface.md                 (まえがき: 〜200行)
├── part1_why-ai-fails/
│   ├── 01-1_the-seventy-percent-problem.md (〜800行)
│   └── 01-2_hidden-costs-and-solutions.md  (〜500行)
├── part2_context-limit/
│   ├── 02-1_lost-in-the-middle.md   (〜700行)
│   └── 02-2_lost-at-the-beginning.md (〜450行)
├── part3_precision/
│   ├── 03-1_scope-convergence.md    (〜750行)
│   └── 03-2_two-stage-ai.md         (〜700行)
├── part4_inference/
│   └── 04-1_leave-room-for-thinking.md (〜650行)
├── part5_failures/
│   └── 05-1_before-after-patterns.md (〜750行)
├── part6_vscode/
│   └── 06-1_practical-tips.md       (この章: 〜750行)
└── part7_new-roles/
    └── 07-1_human-as-divider.md     (〜500行)
```

**分割のポイント**：
- 各章は500〜800行に収める
- 長くなった第1章は01-1と01-2に分割
- 部（Part）ごとにディレクトリを分ける
- AIに「この章を校正して」と渡しやすいサイズ

---

## 6.7　章末チェックリスト

### ファイル分割のチェックリスト

- [ ] 各ファイルは500行以下か
- [ ] 1ファイル = 1責務になっているか
- [ ] ファイル名から内容が推測できるか
- [ ] 関連する情報は近くに配置されているか
- [ ] AIに渡すときに過不足がないか

### AIへの渡し方チェックリスト

- [ ] 全体像を先に伝えたか
- [ ] 渡すファイルは3〜5個以内か
- [ ] 修正対象ファイルを明確に指定したか
- [ ] 関連ファイルの参照理由を明記したか
- [ ] 指示は具体的で小さいか

### VSCode + Claude Code活用チェックリスト

- [ ] @参照を効果的に使っているか
- [ ] 一度に1つの修正を依頼しているか
- [ ] AIの出力を検証しているか
- [ ] 複数の修正は分けて依頼しているか

---

<div class="column-box">

### 🧰 コラム：職人の道具箱

大工さんの道具箱を見たことがありますか？

のこぎり、かんな、ハンマー、それぞれが**専用の役割**を持っています。大工さんは、作業内容に応じて道具を選びます。

ファイル分割も同じです。1つのファイルに全部を詰め込むのではなく、役割ごとに分けることで、AIに「今はこの道具だけ使って」と指示できるようになります。

「ファイル分割 = AIのための道具箱づくり」なのです。

**AI侍**: 「職人は道具を見ればその腕がわかる。ファイル分割も同じじゃ」  
**DJ町娘**: 「役割ごとに分けておけば、AIに『この道具だけ使って』って指示できるんですね！」

</div>

---

## 6.8　次部への橋渡し

この章では、実際の開発環境でのファイル分割とAI活用について学びました。

- ファイル分割 = AIのコンテキスト設計
- 500行以下を目安に分割
- AIには3〜5ファイルまでを渡す
- 具体的で小さな指示を出す

これで、本書の実践的な内容は終わりです。

最後の第7部では、**AIと人間の新しい役割分担**について考えます。

- 人間の仕事は「分けること」になる
- AIは「小さいことを正確に」
- 組み合わせで大きな成果を出す

これまで学んできた「コンテキスト縮小戦略」は、単なるテクニックではありません。AIと人間がどう協働するかという、**新しい働き方**への入り口なのです。

→ 第7-1章「人間の仕事は『分けること』になる」へ
